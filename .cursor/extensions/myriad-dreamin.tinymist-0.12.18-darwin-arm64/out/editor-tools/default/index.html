<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- https://github.com/darkreader/darkreader/blob/main/CONTRIBUTING.md#disabling-dark-reader-on-your-site -->
    <meta name="darkreader-lock" />

    <title>Editor Tools</title>
    <style id="preview-theme-styles"></style>
    <script type="module" crossorigin>
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
const style = "";
let protoOf = Object.getPrototypeOf;
let changedStates, derivedStates, curDeps, curNewDerives, alwaysConnectedDom = { isConnected: 1 };
let gcCycleInMs = 1e3, statesToGc, propSetterCache = {};
let objProto = protoOf(alwaysConnectedDom), funcProto = protoOf(protoOf), _undefined;
let addAndScheduleOnFirst = (set, s, f, waitMs) => (set ?? (setTimeout(f, waitMs), /* @__PURE__ */ new Set())).add(s);
let runAndCaptureDeps = (f, deps, arg) => {
  let prevDeps = curDeps;
  curDeps = deps;
  try {
    return f(arg);
  } catch (e) {
    console.error(e);
    return arg;
  } finally {
    curDeps = prevDeps;
  }
};
let keepConnected = (l) => l.filter((b) => {
  var _a2;
  return (_a2 = b._dom) == null ? void 0 : _a2.isConnected;
});
let addStatesToGc = (d) => statesToGc = addAndScheduleOnFirst(statesToGc, d, () => {
  for (let s of statesToGc)
    s._bindings = keepConnected(s._bindings), s._listeners = keepConnected(s._listeners);
  statesToGc = _undefined;
}, gcCycleInMs);
let stateProto = {
  get val() {
    var _a2;
    (_a2 = curDeps == null ? void 0 : curDeps._getters) == null ? void 0 : _a2.add(this);
    return this.rawVal;
  },
  get oldVal() {
    var _a2;
    (_a2 = curDeps == null ? void 0 : curDeps._getters) == null ? void 0 : _a2.add(this);
    return this._oldVal;
  },
  set val(v) {
    var _a2;
    (_a2 = curDeps == null ? void 0 : curDeps._setters) == null ? void 0 : _a2.add(this);
    if (v !== this.rawVal) {
      this.rawVal = v;
      this._bindings.length + this._listeners.length ? (derivedStates == null ? void 0 : derivedStates.add(this), changedStates = addAndScheduleOnFirst(changedStates, this, updateDoms)) : this._oldVal = v;
    }
  }
};
let state = (initVal) => ({
  __proto__: stateProto,
  rawVal: initVal,
  _oldVal: initVal,
  _bindings: [],
  _listeners: []
});
let bind = (f, dom) => {
  let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, binding = { f }, prevNewDerives = curNewDerives;
  curNewDerives = [];
  let newDom = runAndCaptureDeps(f, deps, dom);
  newDom = (newDom ?? document).nodeType ? newDom : new Text(newDom);
  for (let d of deps._getters)
    deps._setters.has(d) || (addStatesToGc(d), d._bindings.push(binding));
  for (let l of curNewDerives)
    l._dom = newDom;
  curNewDerives = prevNewDerives;
  return binding._dom = newDom;
};
let derive = (f, s = state(), dom) => {
  let deps = { _getters: /* @__PURE__ */ new Set(), _setters: /* @__PURE__ */ new Set() }, listener = { f, s };
  listener._dom = dom ?? (curNewDerives == null ? void 0 : curNewDerives.push(listener)) ?? alwaysConnectedDom;
  s.val = runAndCaptureDeps(f, deps, s.rawVal);
  for (let d of deps._getters)
    deps._setters.has(d) || (addStatesToGc(d), d._listeners.push(listener));
  return s;
};
let add = (dom, ...children) => {
  for (let c of children.flat(Infinity)) {
    let protoOfC = protoOf(c ?? 0);
    let child = protoOfC === stateProto ? bind(() => c.val) : protoOfC === funcProto ? bind(c) : c;
    child != _undefined && dom.append(child);
  }
  return dom;
};
let tag = (ns, name, ...args) => {
  var _a2;
  let [props, ...children] = protoOf(args[0] ?? 0) === objProto ? args : [{}, ...args];
  let dom = ns ? document.createElementNS(ns, name) : document.createElement(name);
  for (let [k, v] of Object.entries(props)) {
    let getPropDescriptor = (proto) => proto ? Object.getOwnPropertyDescriptor(proto, k) ?? getPropDescriptor(protoOf(proto)) : _undefined;
    let cacheKey = name + "," + k;
    let propSetter = propSetterCache[cacheKey] ?? (propSetterCache[cacheKey] = ((_a2 = getPropDescriptor(protoOf(dom))) == null ? void 0 : _a2.set) ?? 0);
    let setter = k.startsWith("on") ? (v2, oldV) => {
      let event = k.slice(2);
      dom.removeEventListener(event, oldV);
      dom.addEventListener(event, v2);
    } : propSetter ? propSetter.bind(dom) : dom.setAttribute.bind(dom, k);
    let protoOfV = protoOf(v ?? 0);
    k.startsWith("on") || protoOfV === funcProto && (v = derive(v), protoOfV = stateProto);
    protoOfV === stateProto ? bind(() => (setter(v.val, v._oldVal), dom)) : setter(v);
  }
  return add(dom, children);
};
let handler = (ns) => ({ get: (_, name) => tag.bind(_undefined, ns, name) });
let update = (dom, newDom) => newDom ? newDom !== dom && dom.replaceWith(newDom) : dom.remove();
let updateDoms = () => {
  let iter = 0, derivedStatesArray = [...changedStates].filter((s) => s.rawVal !== s._oldVal);
  do {
    derivedStates = /* @__PURE__ */ new Set();
    for (let l of new Set(derivedStatesArray.flatMap((s) => s._listeners = keepConnected(s._listeners))))
      derive(l.f, l.s, l._dom), l._dom = _undefined;
  } while (++iter < 100 && (derivedStatesArray = [...derivedStates]).length);
  let changedStatesArray = [...changedStates].filter((s) => s.rawVal !== s._oldVal);
  changedStates = _undefined;
  for (let b of new Set(changedStatesArray.flatMap((s) => s._bindings = keepConnected(s._bindings))))
    update(b._dom, bind(b.f, b._dom)), b._dom = _undefined;
  for (let s of changedStatesArray)
    s._oldVal = s.rawVal;
};
const van = {
  tags: new Proxy((ns) => new Proxy(tag, handler(ns)), handler()),
  hydrate: (dom, f) => update(dom, bind(f, dom)),
  add,
  state,
  derive
};
const vscodeAPI = typeof acquireVsCodeApi !== "undefined" && acquireVsCodeApi();
const traceData = van.state(void 0);
const styleAtCursor = van.state(void 0);
function setupVscodeChannel() {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    window.addEventListener("message", (event) => {
      switch (event.data.type) {
        case "traceData": {
          traceData.val = event.data.data;
          break;
        }
        case "styleAtCursor": {
          styleAtCursor.val = event.data.data;
        }
      }
    });
  }
}
function requestSavePackageData(data) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "savePackageData", data });
  }
}
function requestSaveFontsExportConfigure(data) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "saveFontsExportConfigure", data });
  }
}
function requestInitTemplate(packageSpec) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "initTemplate", packageSpec });
  }
}
function requestRevealPath(path) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "revealPath", path });
  }
}
function copyToClipboard(content) {
  if (content === void 0) {
    return;
  }
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "copyToClipboard", content });
  } else {
    navigator.clipboard.writeText(content);
  }
}
function requestTextEdit(edit) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "editText", edit });
  } else {
    navigator.clipboard.writeText(
      typeof edit.newText === "string" ? edit.newText : edit.newText.code || edit.newText.rest || ""
    );
  }
}
function saveDataToFile({
  data,
  path,
  option
}) {
  if (vscodeAPI == null ? void 0 : vscodeAPI.postMessage) {
    vscodeAPI.postMessage({ type: "saveDataToFile", data, path, option });
  }
}
function retrieveArgs() {
  let mode = `editor-tools-args:{"page": "font-view"}`;
  mode = mode.replace("editor-tools-args:", "");
  return JSON.parse(mode);
}
function mainHarness(components) {
  setupVscodeChannel();
  const args = retrieveArgs();
  const appHook = document.querySelector("#tinymist-app");
  const Component = components[args.page];
  if (!Component) {
    throw new Error(`Unknown page: ${args.page}`);
  }
  van.add(appHook, Component());
}
const { div: div$6, span: span$6 } = van.tags;
const HeartIcon = (sz = 16) => div$6({
  class: "tinymist-icon",
  style: `height: ${sz}px; width: ${sz}px;`,
  innerHTML: `<svg width="${sz}px" height="${sz}px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
  <path d="M10.8049818,3 C8.78471579,3 8.00065285,5.34486486 8.00065285,5.34486486 C8.00065285,5.34486486 7.21296387,3 5.19604494,3 C3.49431318,3 1.748374,4.09592694 2.03008996,6.51430532 C2.37372765,9.46673775 7.75491917,12.9928738 7.99310958,13.0010557 C8.23129998,13.0092378 13.7309828,9.2785378 13.981459,6.5012405 C14.1878647,4.20097023 12.5067136,3 10.8049818,3 Z"/>
</g>
</svg>`
});
const AddIcon = (sz = 16) => div$6({
  class: "tinymist-icon",
  style: `height: ${sz}px; width: ${sz}px;`,
  innerHTML: `<svg width="${sz}px" height="${sz}px" viewBox="-1 0 17 17">
  <path d="M7.75 2a.75.75 0 0 1 .75.75V7h4.25a.75.75 0 0 1 0 1.5H8.5v4.25a.75.75 0 0 1-1.5 0V8.5H2.75a.75.75 0 0 1 0-1.5H7V2.75A.75.75 0 0 1 7.75 2Z"></path>
</svg>`
});
const CopyIcon = (sz = 16) => div$6({
  class: "tinymist-icon",
  style: `height: ${sz}px; width: ${sz}px;`,
  innerHTML: `<svg width="${sz}px" height="${sz}px" viewBox="0 0 16 16" version="1.1"
  xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <g stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
    <rect class="stroke-based" width="9.8202543" height="11.792212" x="1.742749" y="3.4055943" ry="0.49967012" />
    <path class="stroke-based" d="m 5.1841347,0.82574918 9.0495613,0.0341483 V 12.129165" />
    <path class="stroke-based" d="M 3.6542046,6.2680732 H 9.3239071" />
    <path class="stroke-based" d="M 3.6542046,12.48578 H 7.7302609" />
    <path class="stroke-based" d="M 3.6542046,9.3769264 H 7.7302609" />
  </g>
</svg>`
});
const bytes2utf8 = new TextDecoder("utf-8");
const utf82bytes = new TextEncoder();
const base64Decode = (encoded) => bytes2utf8.decode(Uint8Array.from(atob(encoded), (m) => m.charCodeAt(0)));
const base64Encode = (utf8Str) => btoa(
  Array.from(utf82bytes.encode(utf8Str), (c) => String.fromCharCode(c)).join(
    ""
  )
);
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s = arguments[i2];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i2 >= o.length)
          o = void 0;
        return { value: o && o[i2++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"]))
        m.call(i2);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
var ENTRIES = "ENTRIES";
var KEYS = "KEYS";
var VALUES = "VALUES";
var LEAF = "";
var TreeIterator = (
  /** @class */
  function() {
    function TreeIterator2(set, type) {
      var node = set._tree;
      var keys = Array.from(node.keys());
      this.set = set;
      this._type = type;
      this._path = keys.length > 0 ? [{ node, keys }] : [];
    }
    TreeIterator2.prototype.next = function() {
      var value = this.dive();
      this.backtrack();
      return value;
    };
    TreeIterator2.prototype.dive = function() {
      if (this._path.length === 0) {
        return { done: true, value: void 0 };
      }
      var _a2 = last$1(this._path), node = _a2.node, keys = _a2.keys;
      if (last$1(keys) === LEAF) {
        return { done: false, value: this.result() };
      }
      var child = node.get(last$1(keys));
      this._path.push({ node: child, keys: Array.from(child.keys()) });
      return this.dive();
    };
    TreeIterator2.prototype.backtrack = function() {
      if (this._path.length === 0) {
        return;
      }
      var keys = last$1(this._path).keys;
      keys.pop();
      if (keys.length > 0) {
        return;
      }
      this._path.pop();
      this.backtrack();
    };
    TreeIterator2.prototype.key = function() {
      return this.set._prefix + this._path.map(function(_a2) {
        var keys = _a2.keys;
        return last$1(keys);
      }).filter(function(key) {
        return key !== LEAF;
      }).join("");
    };
    TreeIterator2.prototype.value = function() {
      return last$1(this._path).node.get(LEAF);
    };
    TreeIterator2.prototype.result = function() {
      switch (this._type) {
        case VALUES:
          return this.value();
        case KEYS:
          return this.key();
        default:
          return [this.key(), this.value()];
      }
    };
    TreeIterator2.prototype[Symbol.iterator] = function() {
      return this;
    };
    return TreeIterator2;
  }()
);
var last$1 = function(array) {
  return array[array.length - 1];
};
var fuzzySearch = function(node, query, maxDistance) {
  var results = /* @__PURE__ */ new Map();
  if (query === void 0)
    return results;
  var n = query.length + 1;
  var m = n + maxDistance;
  var matrix = new Uint8Array(m * n).fill(maxDistance + 1);
  for (var j = 0; j < n; ++j)
    matrix[j] = j;
  for (var i2 = 1; i2 < m; ++i2)
    matrix[i2 * n] = i2;
  recurse(node, query, maxDistance, results, matrix, 1, n, "");
  return results;
};
var recurse = function(node, query, maxDistance, results, matrix, m, n, prefix) {
  var e_1, _a2;
  var offset = m * n;
  try {
    key:
      for (var _b = __values(node.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (key === LEAF) {
          var distance = matrix[offset - 1];
          if (distance <= maxDistance) {
            results.set(prefix, [node.get(key), distance]);
          }
        } else {
          var i2 = m;
          for (var pos = 0; pos < key.length; ++pos, ++i2) {
            var char = key[pos];
            var thisRowOffset = n * i2;
            var prevRowOffset = thisRowOffset - n;
            var minDistance = matrix[thisRowOffset];
            var jmin = Math.max(0, i2 - maxDistance - 1);
            var jmax = Math.min(n - 1, i2 + maxDistance);
            for (var j = jmin; j < jmax; ++j) {
              var different = char !== query[j];
              var rpl = matrix[prevRowOffset + j] + +different;
              var del = matrix[prevRowOffset + j + 1] + 1;
              var ins = matrix[thisRowOffset + j] + 1;
              var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
              if (dist < minDistance)
                minDistance = dist;
            }
            if (minDistance > maxDistance) {
              continue key;
            }
          }
          recurse(node.get(key), query, maxDistance, results, matrix, i2, n, prefix + key);
        }
      }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
};
var SearchableMap = (
  /** @class */
  function() {
    function SearchableMap2(tree, prefix) {
      if (tree === void 0) {
        tree = /* @__PURE__ */ new Map();
      }
      if (prefix === void 0) {
        prefix = "";
      }
      this._size = void 0;
      this._tree = tree;
      this._prefix = prefix;
    }
    SearchableMap2.prototype.atPrefix = function(prefix) {
      var e_1, _a2;
      if (!prefix.startsWith(this._prefix)) {
        throw new Error("Mismatched prefix");
      }
      var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b[0], path = _b[1];
      if (node === void 0) {
        var _c = __read(last(path), 2), parentNode = _c[0], key = _c[1];
        try {
          for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var k = _e.value;
            if (k !== LEAF && k.startsWith(key)) {
              var node_1 = /* @__PURE__ */ new Map();
              node_1.set(k.slice(key.length), parentNode.get(k));
              return new SearchableMap2(node_1, prefix);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e && !_e.done && (_a2 = _d.return))
              _a2.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      return new SearchableMap2(node, prefix);
    };
    SearchableMap2.prototype.clear = function() {
      this._size = void 0;
      this._tree.clear();
    };
    SearchableMap2.prototype.delete = function(key) {
      this._size = void 0;
      return remove(this._tree, key);
    };
    SearchableMap2.prototype.entries = function() {
      return new TreeIterator(this, ENTRIES);
    };
    SearchableMap2.prototype.forEach = function(fn) {
      var e_2, _a2;
      try {
        for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
          fn(key, value, this);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    SearchableMap2.prototype.fuzzyGet = function(key, maxEditDistance) {
      return fuzzySearch(this._tree, key, maxEditDistance);
    };
    SearchableMap2.prototype.get = function(key) {
      var node = lookup$1(this._tree, key);
      return node !== void 0 ? node.get(LEAF) : void 0;
    };
    SearchableMap2.prototype.has = function(key) {
      var node = lookup$1(this._tree, key);
      return node !== void 0 && node.has(LEAF);
    };
    SearchableMap2.prototype.keys = function() {
      return new TreeIterator(this, KEYS);
    };
    SearchableMap2.prototype.set = function(key, value) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      node.set(LEAF, value);
      return this;
    };
    Object.defineProperty(SearchableMap2.prototype, "size", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
       */
      get: function() {
        if (this._size) {
          return this._size;
        }
        this._size = 0;
        var iter = this.entries();
        while (!iter.next().done)
          this._size += 1;
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    SearchableMap2.prototype.update = function(key, fn) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      node.set(LEAF, fn(node.get(LEAF)));
      return this;
    };
    SearchableMap2.prototype.fetch = function(key, initial) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      var value = node.get(LEAF);
      if (value === void 0) {
        node.set(LEAF, value = initial());
      }
      return value;
    };
    SearchableMap2.prototype.values = function() {
      return new TreeIterator(this, VALUES);
    };
    SearchableMap2.prototype[Symbol.iterator] = function() {
      return this.entries();
    };
    SearchableMap2.from = function(entries) {
      var e_3, _a2;
      var tree = new SearchableMap2();
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
          tree.set(key, value);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a2 = entries_1.return))
            _a2.call(entries_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return tree;
    };
    SearchableMap2.fromObject = function(object) {
      return SearchableMap2.from(Object.entries(object));
    };
    return SearchableMap2;
  }()
);
var trackDown = function(tree, key, path) {
  var e_4, _a2;
  if (path === void 0) {
    path = [];
  }
  if (key.length === 0 || tree == null) {
    return [tree, path];
  }
  try {
    for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var k = _c.value;
      if (k !== LEAF && key.startsWith(k)) {
        path.push([tree, k]);
        return trackDown(tree.get(k), key.slice(k.length), path);
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  path.push([tree, key]);
  return trackDown(void 0, "", path);
};
var lookup$1 = function(tree, key) {
  var e_5, _a2;
  if (key.length === 0 || tree == null) {
    return tree;
  }
  try {
    for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var k = _c.value;
      if (k !== LEAF && key.startsWith(k)) {
        return lookup$1(tree.get(k), key.slice(k.length));
      }
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
};
var createPath = function(node, key) {
  var e_6, _a2;
  var keyLength = key.length;
  outer:
    for (var pos = 0; node && pos < keyLength; ) {
      try {
        for (var _b = (e_6 = void 0, __values(node.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
          var k = _c.value;
          if (k !== LEAF && key[pos] === k[0]) {
            var len = Math.min(keyLength - pos, k.length);
            var offset = 1;
            while (offset < len && key[pos + offset] === k[offset])
              ++offset;
            var child_1 = node.get(k);
            if (offset === k.length) {
              node = child_1;
            } else {
              var intermediate = /* @__PURE__ */ new Map();
              intermediate.set(k.slice(offset), child_1);
              node.set(key.slice(pos, pos + offset), intermediate);
              node.delete(k);
              node = intermediate;
            }
            pos += offset;
            continue outer;
          }
        }
      } catch (e_6_1) {
        e_6 = { error: e_6_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      var child = /* @__PURE__ */ new Map();
      node.set(key.slice(pos), child);
      return child;
    }
  return node;
};
var remove = function(tree, key) {
  var _a2 = __read(trackDown(tree, key), 2), node = _a2[0], path = _a2[1];
  if (node === void 0) {
    return;
  }
  node.delete(LEAF);
  if (node.size === 0) {
    cleanup(path);
  } else if (node.size === 1) {
    var _b = __read(node.entries().next().value, 2), key_1 = _b[0], value = _b[1];
    merge(path, key_1, value);
  }
};
var cleanup = function(path) {
  if (path.length === 0) {
    return;
  }
  var _a2 = __read(last(path), 2), node = _a2[0], key = _a2[1];
  node.delete(key);
  if (node.size === 0) {
    cleanup(path.slice(0, -1));
  } else if (node.size === 1) {
    var _b = __read(node.entries().next().value, 2), key_2 = _b[0], value = _b[1];
    if (key_2 !== LEAF) {
      merge(path.slice(0, -1), key_2, value);
    }
  }
};
var merge = function(path, key, value) {
  if (path.length === 0) {
    return;
  }
  var _a2 = __read(last(path), 2), node = _a2[0], nodeKey = _a2[1];
  node.set(nodeKey + key, value);
  node.delete(nodeKey);
};
var last = function(array) {
  return array[array.length - 1];
};
var _a;
var OR = "or";
var AND = "and";
var AND_NOT = "and_not";
var MiniSearch = (
  /** @class */
  function() {
    function MiniSearch2(options) {
      if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
        throw new Error('MiniSearch: option "fields" must be provided');
      }
      var autoVacuum = options.autoVacuum == null || options.autoVacuum === true ? defaultAutoVacuumOptions : options.autoVacuum;
      this._options = __assign(__assign(__assign({}, defaultOptions), options), { autoVacuum, searchOptions: __assign(__assign({}, defaultSearchOptions), options.searchOptions || {}), autoSuggestOptions: __assign(__assign({}, defaultAutoSuggestOptions), options.autoSuggestOptions || {}) });
      this._index = new SearchableMap();
      this._documentCount = 0;
      this._documentIds = /* @__PURE__ */ new Map();
      this._idToShortId = /* @__PURE__ */ new Map();
      this._fieldIds = {};
      this._fieldLength = /* @__PURE__ */ new Map();
      this._avgFieldLength = [];
      this._nextId = 0;
      this._storedFields = /* @__PURE__ */ new Map();
      this._dirtCount = 0;
      this._currentVacuum = null;
      this._enqueuedVacuum = null;
      this._enqueuedVacuumConditions = defaultVacuumConditions;
      this.addFields(this._options.fields);
    }
    MiniSearch2.prototype.add = function(document2) {
      var e_1, _a2, e_2, _b, e_3, _c;
      var _d = this._options, extractField = _d.extractField, tokenize = _d.tokenize, processTerm = _d.processTerm, fields = _d.fields, idField = _d.idField;
      var id = extractField(document2, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
      }
      if (this._idToShortId.has(id)) {
        throw new Error("MiniSearch: duplicate ID ".concat(id));
      }
      var shortDocumentId = this.addDocumentId(id);
      this.saveStoredFields(shortDocumentId, document2);
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field = fields_1_1.value;
          var fieldValue = extractField(document2, field);
          if (fieldValue == null)
            continue;
          var tokens = tokenize(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);
          try {
            for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
              var term = tokens_1_1.value;
              var processedTerm = processTerm(term, field);
              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
                    var t = processedTerm_1_1.value;
                    this.addTerm(fieldId, shortDocumentId, t);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return))
                      _c.call(processedTerm_1);
                  } finally {
                    if (e_3)
                      throw e_3.error;
                  }
                }
              } else if (processedTerm) {
                this.addTerm(fieldId, shortDocumentId, processedTerm);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return))
                _b.call(tokens_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a2 = fields_1.return))
            _a2.call(fields_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MiniSearch2.prototype.addAll = function(documents) {
      var e_4, _a2;
      try {
        for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
          var document_1 = documents_1_1.value;
          this.add(document_1);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (documents_1_1 && !documents_1_1.done && (_a2 = documents_1.return))
            _a2.call(documents_1);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    MiniSearch2.prototype.addAllAsync = function(documents, options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      var _a2 = options.chunkSize, chunkSize = _a2 === void 0 ? 10 : _a2;
      var acc = { chunk: [], promise: Promise.resolve() };
      var _b = documents.reduce(function(_a3, document2, i2) {
        var chunk2 = _a3.chunk, promise2 = _a3.promise;
        chunk2.push(document2);
        if ((i2 + 1) % chunkSize === 0) {
          return {
            chunk: [],
            promise: promise2.then(function() {
              return new Promise(function(resolve) {
                return setTimeout(resolve, 0);
              });
            }).then(function() {
              return _this.addAll(chunk2);
            })
          };
        } else {
          return { chunk: chunk2, promise: promise2 };
        }
      }, acc), chunk = _b.chunk, promise = _b.promise;
      return promise.then(function() {
        return _this.addAll(chunk);
      });
    };
    MiniSearch2.prototype.remove = function(document2) {
      var e_5, _a2, e_6, _b, e_7, _c;
      var _d = this._options, tokenize = _d.tokenize, processTerm = _d.processTerm, extractField = _d.extractField, fields = _d.fields, idField = _d.idField;
      var id = extractField(document2, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
      }
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        throw new Error("MiniSearch: cannot remove document with ID ".concat(id, ": it is not in the index"));
      }
      try {
        for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
          var field = fields_2_1.value;
          var fieldValue = extractField(document2, field);
          if (fieldValue == null)
            continue;
          var tokens = tokenize(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);
          try {
            for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
              var term = tokens_2_1.value;
              var processedTerm = processTerm(term, field);
              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
                    var t = processedTerm_2_1.value;
                    this.removeTerm(fieldId, shortId, t);
                  }
                } catch (e_7_1) {
                  e_7 = { error: e_7_1 };
                } finally {
                  try {
                    if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return))
                      _c.call(processedTerm_2);
                  } finally {
                    if (e_7)
                      throw e_7.error;
                  }
                }
              } else if (processedTerm) {
                this.removeTerm(fieldId, shortId, processedTerm);
              }
            }
          } catch (e_6_1) {
            e_6 = { error: e_6_1 };
          } finally {
            try {
              if (tokens_2_1 && !tokens_2_1.done && (_b = tokens_2.return))
                _b.call(tokens_2);
            } finally {
              if (e_6)
                throw e_6.error;
            }
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (fields_2_1 && !fields_2_1.done && (_a2 = fields_2.return))
            _a2.call(fields_2);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      this._storedFields.delete(shortId);
      this._documentIds.delete(shortId);
      this._idToShortId.delete(id);
      this._fieldLength.delete(shortId);
      this._documentCount -= 1;
    };
    MiniSearch2.prototype.removeAll = function(documents) {
      var e_8, _a2;
      if (documents) {
        try {
          for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
            var document_2 = documents_2_1.value;
            this.remove(document_2);
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (documents_2_1 && !documents_2_1.done && (_a2 = documents_2.return))
              _a2.call(documents_2);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
      } else if (arguments.length > 0) {
        throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
      } else {
        this._index = new SearchableMap();
        this._documentCount = 0;
        this._documentIds = /* @__PURE__ */ new Map();
        this._idToShortId = /* @__PURE__ */ new Map();
        this._fieldLength = /* @__PURE__ */ new Map();
        this._avgFieldLength = [];
        this._storedFields = /* @__PURE__ */ new Map();
        this._nextId = 0;
      }
    };
    MiniSearch2.prototype.discard = function(id) {
      var _this = this;
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        throw new Error("MiniSearch: cannot discard document with ID ".concat(id, ": it is not in the index"));
      }
      this._idToShortId.delete(id);
      this._documentIds.delete(shortId);
      this._storedFields.delete(shortId);
      (this._fieldLength.get(shortId) || []).forEach(function(fieldLength, fieldId) {
        _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
      });
      this._fieldLength.delete(shortId);
      this._documentCount -= 1;
      this._dirtCount += 1;
      this.maybeAutoVacuum();
    };
    MiniSearch2.prototype.maybeAutoVacuum = function() {
      if (this._options.autoVacuum === false) {
        return;
      }
      var _a2 = this._options.autoVacuum, minDirtFactor = _a2.minDirtFactor, minDirtCount = _a2.minDirtCount, batchSize = _a2.batchSize, batchWait = _a2.batchWait;
      this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });
    };
    MiniSearch2.prototype.discardAll = function(ids) {
      var e_9, _a2;
      var autoVacuum = this._options.autoVacuum;
      try {
        this._options.autoVacuum = false;
        try {
          for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            this.discard(id);
          }
        } catch (e_9_1) {
          e_9 = { error: e_9_1 };
        } finally {
          try {
            if (ids_1_1 && !ids_1_1.done && (_a2 = ids_1.return))
              _a2.call(ids_1);
          } finally {
            if (e_9)
              throw e_9.error;
          }
        }
      } finally {
        this._options.autoVacuum = autoVacuum;
      }
      this.maybeAutoVacuum();
    };
    MiniSearch2.prototype.replace = function(updatedDocument) {
      var _a2 = this._options, idField = _a2.idField, extractField = _a2.extractField;
      var id = extractField(updatedDocument, idField);
      this.discard(id);
      this.add(updatedDocument);
    };
    MiniSearch2.prototype.vacuum = function(options) {
      if (options === void 0) {
        options = {};
      }
      return this.conditionalVacuum(options);
    };
    MiniSearch2.prototype.conditionalVacuum = function(options, conditions) {
      var _this = this;
      if (this._currentVacuum) {
        this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;
        if (this._enqueuedVacuum != null) {
          return this._enqueuedVacuum;
        }
        this._enqueuedVacuum = this._currentVacuum.then(function() {
          var conditions2 = _this._enqueuedVacuumConditions;
          _this._enqueuedVacuumConditions = defaultVacuumConditions;
          return _this.performVacuuming(options, conditions2);
        });
        return this._enqueuedVacuum;
      }
      if (this.vacuumConditionsMet(conditions) === false) {
        return Promise.resolve();
      }
      this._currentVacuum = this.performVacuuming(options);
      return this._currentVacuum;
    };
    MiniSearch2.prototype.performVacuuming = function(options, conditions) {
      return __awaiter(this, void 0, void 0, function() {
        var initialDirtCount, batchSize, batchWait_1, i2, _a2, _b, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;
        var e_10, _f, e_11, _g, e_12, _h;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              initialDirtCount = this._dirtCount;
              if (!this.vacuumConditionsMet(conditions))
                return [3, 10];
              batchSize = options.batchSize || defaultVacuumOptions.batchSize;
              batchWait_1 = options.batchWait || defaultVacuumOptions.batchWait;
              i2 = 1;
              _j.label = 1;
            case 1:
              _j.trys.push([1, 7, 8, 9]);
              _a2 = __values(this._index), _b = _a2.next();
              _j.label = 2;
            case 2:
              if (!!_b.done)
                return [3, 6];
              _c = __read(_b.value, 2), term = _c[0], fieldsData = _c[1];
              try {
                for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
                  _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];
                  try {
                    for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
                      _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];
                      if (this._documentIds.has(shortId)) {
                        continue;
                      }
                      if (fieldIndex.size <= 1) {
                        fieldsData.delete(fieldId);
                      } else {
                        fieldIndex.delete(shortId);
                      }
                    }
                  } catch (e_12_1) {
                    e_12 = { error: e_12_1 };
                  } finally {
                    try {
                      if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return))
                        _h.call(fieldIndex_1);
                    } finally {
                      if (e_12)
                        throw e_12.error;
                    }
                  }
                }
              } catch (e_11_1) {
                e_11 = { error: e_11_1 };
              } finally {
                try {
                  if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return))
                    _g.call(fieldsData_1);
                } finally {
                  if (e_11)
                    throw e_11.error;
                }
              }
              if (this._index.get(term).size === 0) {
                this._index.delete(term);
              }
              if (!(i2 % batchSize === 0))
                return [3, 4];
              return [4, new Promise(function(resolve) {
                return setTimeout(resolve, batchWait_1);
              })];
            case 3:
              _j.sent();
              _j.label = 4;
            case 4:
              i2 += 1;
              _j.label = 5;
            case 5:
              _b = _a2.next();
              return [3, 2];
            case 6:
              return [3, 9];
            case 7:
              e_10_1 = _j.sent();
              e_10 = { error: e_10_1 };
              return [3, 9];
            case 8:
              try {
                if (_b && !_b.done && (_f = _a2.return))
                  _f.call(_a2);
              } finally {
                if (e_10)
                  throw e_10.error;
              }
              return [
                7
                /*endfinally*/
              ];
            case 9:
              this._dirtCount -= initialDirtCount;
              _j.label = 10;
            case 10:
              return [4, null];
            case 11:
              _j.sent();
              this._currentVacuum = this._enqueuedVacuum;
              this._enqueuedVacuum = null;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    MiniSearch2.prototype.vacuumConditionsMet = function(conditions) {
      if (conditions == null) {
        return true;
      }
      var minDirtCount = conditions.minDirtCount, minDirtFactor = conditions.minDirtFactor;
      minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
      minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
      return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
    };
    Object.defineProperty(MiniSearch2.prototype, "isVacuuming", {
      /**
       * Is `true` if a vacuuming operation is ongoing, `false` otherwise
       */
      get: function() {
        return this._currentVacuum != null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "dirtCount", {
      /**
       * The number of documents discarded since the most recent vacuuming
       */
      get: function() {
        return this._dirtCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "dirtFactor", {
      /**
       * A number between 0 and 1 giving an indication about the proportion of
       * documents that are discarded, and can therefore be cleaned up by vacuuming.
       * A value close to 0 means that the index is relatively clean, while a higher
       * value means that the index is relatively dirty, and vacuuming could release
       * memory.
       */
      get: function() {
        return this._dirtCount / (1 + this._documentCount + this._dirtCount);
      },
      enumerable: false,
      configurable: true
    });
    MiniSearch2.prototype.has = function(id) {
      return this._idToShortId.has(id);
    };
    MiniSearch2.prototype.getStoredFields = function(id) {
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        return void 0;
      }
      return this._storedFields.get(shortId);
    };
    MiniSearch2.prototype.search = function(query, searchOptions) {
      var e_13, _a2;
      if (searchOptions === void 0) {
        searchOptions = {};
      }
      var rawResults = this.executeQuery(query, searchOptions);
      var results = [];
      try {
        for (var rawResults_1 = __values(rawResults), rawResults_1_1 = rawResults_1.next(); !rawResults_1_1.done; rawResults_1_1 = rawResults_1.next()) {
          var _b = __read(rawResults_1_1.value, 2), docId = _b[0], _c = _b[1], score = _c.score, terms = _c.terms, match = _c.match;
          var quality = terms.length || 1;
          var result = {
            id: this._documentIds.get(docId),
            score: score * quality,
            terms: Object.keys(match),
            queryTerms: terms,
            match
          };
          Object.assign(result, this._storedFields.get(docId));
          if (searchOptions.filter == null || searchOptions.filter(result)) {
            results.push(result);
          }
        }
      } catch (e_13_1) {
        e_13 = { error: e_13_1 };
      } finally {
        try {
          if (rawResults_1_1 && !rawResults_1_1.done && (_a2 = rawResults_1.return))
            _a2.call(rawResults_1);
        } finally {
          if (e_13)
            throw e_13.error;
        }
      }
      if (query === MiniSearch2.wildcard && searchOptions.boostDocument == null && this._options.searchOptions.boostDocument == null) {
        return results;
      }
      results.sort(byScore);
      return results;
    };
    MiniSearch2.prototype.autoSuggest = function(queryString, options) {
      var e_14, _a2, e_15, _b;
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, this._options.autoSuggestOptions), options);
      var suggestions = /* @__PURE__ */ new Map();
      try {
        for (var _c = __values(this.search(queryString, options)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = _d.value, score = _e.score, terms = _e.terms;
          var phrase = terms.join(" ");
          var suggestion = suggestions.get(phrase);
          if (suggestion != null) {
            suggestion.score += score;
            suggestion.count += 1;
          } else {
            suggestions.set(phrase, { score, terms, count: 1 });
          }
        }
      } catch (e_14_1) {
        e_14 = { error: e_14_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a2 = _c.return))
            _a2.call(_c);
        } finally {
          if (e_14)
            throw e_14.error;
        }
      }
      var results = [];
      try {
        for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
          var _f = __read(suggestions_1_1.value, 2), suggestion = _f[0], _g = _f[1], score = _g.score, terms = _g.terms, count = _g.count;
          results.push({ suggestion, terms, score: score / count });
        }
      } catch (e_15_1) {
        e_15 = { error: e_15_1 };
      } finally {
        try {
          if (suggestions_1_1 && !suggestions_1_1.done && (_b = suggestions_1.return))
            _b.call(suggestions_1);
        } finally {
          if (e_15)
            throw e_15.error;
        }
      }
      results.sort(byScore);
      return results;
    };
    Object.defineProperty(MiniSearch2.prototype, "documentCount", {
      /**
       * Total number of documents available to search
       */
      get: function() {
        return this._documentCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "termCount", {
      /**
       * Number of terms in the index
       */
      get: function() {
        return this._index.size;
      },
      enumerable: false,
      configurable: true
    });
    MiniSearch2.loadJSON = function(json, options) {
      if (options == null) {
        throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
      }
      return this.loadJS(JSON.parse(json), options);
    };
    MiniSearch2.getDefault = function(optionName) {
      if (defaultOptions.hasOwnProperty(optionName)) {
        return getOwnProperty(defaultOptions, optionName);
      } else {
        throw new Error('MiniSearch: unknown option "'.concat(optionName, '"'));
      }
    };
    MiniSearch2.loadJS = function(js, options) {
      var e_16, _a2, e_17, _b, e_18, _c;
      var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields, dirtCount = js.dirtCount, serializationVersion = js.serializationVersion;
      if (serializationVersion !== 1 && serializationVersion !== 2) {
        throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");
      }
      var miniSearch = new MiniSearch2(options);
      miniSearch._documentCount = documentCount;
      miniSearch._nextId = nextId;
      miniSearch._documentIds = objectToNumericMap(documentIds);
      miniSearch._idToShortId = /* @__PURE__ */ new Map();
      miniSearch._fieldIds = fieldIds;
      miniSearch._fieldLength = objectToNumericMap(fieldLength);
      miniSearch._avgFieldLength = averageFieldLength;
      miniSearch._storedFields = objectToNumericMap(storedFields);
      miniSearch._dirtCount = dirtCount || 0;
      miniSearch._index = new SearchableMap();
      try {
        for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
          var _f = __read(_e.value, 2), shortId = _f[0], id = _f[1];
          miniSearch._idToShortId.set(id, shortId);
        }
      } catch (e_16_1) {
        e_16 = { error: e_16_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a2 = _d.return))
            _a2.call(_d);
        } finally {
          if (e_16)
            throw e_16.error;
        }
      }
      try {
        for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
          var _g = __read(index_1_1.value, 2), term = _g[0], data = _g[1];
          var dataMap = /* @__PURE__ */ new Map();
          try {
            for (var _h = (e_18 = void 0, __values(Object.keys(data))), _j = _h.next(); !_j.done; _j = _h.next()) {
              var fieldId = _j.value;
              var indexEntry = data[fieldId];
              if (serializationVersion === 1) {
                indexEntry = indexEntry.ds;
              }
              dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
            }
          } catch (e_18_1) {
            e_18 = { error: e_18_1 };
          } finally {
            try {
              if (_j && !_j.done && (_c = _h.return))
                _c.call(_h);
            } finally {
              if (e_18)
                throw e_18.error;
            }
          }
          miniSearch._index.set(term, dataMap);
        }
      } catch (e_17_1) {
        e_17 = { error: e_17_1 };
      } finally {
        try {
          if (index_1_1 && !index_1_1.done && (_b = index_1.return))
            _b.call(index_1);
        } finally {
          if (e_17)
            throw e_17.error;
        }
      }
      return miniSearch;
    };
    MiniSearch2.prototype.executeQuery = function(query, searchOptions) {
      var _this = this;
      if (searchOptions === void 0) {
        searchOptions = {};
      }
      if (query === MiniSearch2.wildcard) {
        return this.executeWildcardQuery(searchOptions);
      }
      if (typeof query !== "string") {
        var options_1 = __assign(__assign(__assign({}, searchOptions), query), { queries: void 0 });
        var results_1 = query.queries.map(function(subquery) {
          return _this.executeQuery(subquery, options_1);
        });
        return this.combineResults(results_1, options_1.combineWith);
      }
      var _a2 = this._options, tokenize = _a2.tokenize, processTerm = _a2.processTerm, globalSearchOptions = _a2.searchOptions;
      var options = __assign(__assign({ tokenize, processTerm }, globalSearchOptions), searchOptions);
      var searchTokenize = options.tokenize, searchProcessTerm = options.processTerm;
      var terms = searchTokenize(query).flatMap(function(term) {
        return searchProcessTerm(term);
      }).filter(function(term) {
        return !!term;
      });
      var queries = terms.map(termToQuerySpec(options));
      var results = queries.map(function(query2) {
        return _this.executeQuerySpec(query2, options);
      });
      return this.combineResults(results, options.combineWith);
    };
    MiniSearch2.prototype.executeQuerySpec = function(query, searchOptions) {
      var e_19, _a2, e_20, _b;
      var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
      var boosts = (options.fields || this._options.fields).reduce(function(boosts2, field) {
        var _a3;
        return __assign(__assign({}, boosts2), (_a3 = {}, _a3[field] = getOwnProperty(options.boost, field) || 1, _a3));
      }, {});
      var boostDocument = options.boostDocument, weights = options.weights, maxFuzzy = options.maxFuzzy, bm25params = options.bm25;
      var _c = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _c.fuzzy, prefixWeight = _c.prefix;
      var data = this._index.get(query.term);
      var results = this.termResults(query.term, query.term, 1, data, boosts, boostDocument, bm25params);
      var prefixMatches;
      var fuzzyMatches;
      if (query.prefix) {
        prefixMatches = this._index.atPrefix(query.term);
      }
      if (query.fuzzy) {
        var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
        var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
        if (maxDistance)
          fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
      }
      if (prefixMatches) {
        try {
          for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
            var _d = __read(prefixMatches_1_1.value, 2), term = _d[0], data_1 = _d[1];
            var distance = term.length - query.term.length;
            if (!distance) {
              continue;
            }
            fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);
            var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
            this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
          }
        } catch (e_19_1) {
          e_19 = { error: e_19_1 };
        } finally {
          try {
            if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a2 = prefixMatches_1.return))
              _a2.call(prefixMatches_1);
          } finally {
            if (e_19)
              throw e_19.error;
          }
        }
      }
      if (fuzzyMatches) {
        try {
          for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var term = _f.value;
            var _g = __read(fuzzyMatches.get(term), 2), data_2 = _g[0], distance = _g[1];
            if (!distance) {
              continue;
            }
            var weight = fuzzyWeight * term.length / (term.length + distance);
            this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
          }
        } catch (e_20_1) {
          e_20 = { error: e_20_1 };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return))
              _b.call(_e);
          } finally {
            if (e_20)
              throw e_20.error;
          }
        }
      }
      return results;
    };
    MiniSearch2.prototype.executeWildcardQuery = function(searchOptions) {
      var e_21, _a2;
      var results = /* @__PURE__ */ new Map();
      var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
      try {
        for (var _b = __values(this._documentIds), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), shortId = _d[0], id = _d[1];
          var score = options.boostDocument ? options.boostDocument(id, "", this._storedFields.get(shortId)) : 1;
          results.set(shortId, {
            score,
            terms: [],
            match: {}
          });
        }
      } catch (e_21_1) {
        e_21 = { error: e_21_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_21)
            throw e_21.error;
        }
      }
      return results;
    };
    MiniSearch2.prototype.combineResults = function(results, combineWith) {
      if (combineWith === void 0) {
        combineWith = OR;
      }
      if (results.length === 0) {
        return /* @__PURE__ */ new Map();
      }
      var operator = combineWith.toLowerCase();
      return results.reduce(combinators[operator]) || /* @__PURE__ */ new Map();
    };
    MiniSearch2.prototype.toJSON = function() {
      var e_22, _a2, e_23, _b;
      var index = [];
      try {
        for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read(_d.value, 2), term = _e[0], fieldIndex = _e[1];
          var data = {};
          try {
            for (var fieldIndex_2 = (e_23 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
              var _f = __read(fieldIndex_2_1.value, 2), fieldId = _f[0], freqs = _f[1];
              data[fieldId] = Object.fromEntries(freqs);
            }
          } catch (e_23_1) {
            e_23 = { error: e_23_1 };
          } finally {
            try {
              if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b = fieldIndex_2.return))
                _b.call(fieldIndex_2);
            } finally {
              if (e_23)
                throw e_23.error;
            }
          }
          index.push([term, data]);
        }
      } catch (e_22_1) {
        e_22 = { error: e_22_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a2 = _c.return))
            _a2.call(_c);
        } finally {
          if (e_22)
            throw e_22.error;
        }
      }
      return {
        documentCount: this._documentCount,
        nextId: this._nextId,
        documentIds: Object.fromEntries(this._documentIds),
        fieldIds: this._fieldIds,
        fieldLength: Object.fromEntries(this._fieldLength),
        averageFieldLength: this._avgFieldLength,
        storedFields: Object.fromEntries(this._storedFields),
        dirtCount: this._dirtCount,
        index,
        serializationVersion: 2
      };
    };
    MiniSearch2.prototype.termResults = function(sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
      var e_24, _a2, e_25, _b, _c;
      if (results === void 0) {
        results = /* @__PURE__ */ new Map();
      }
      if (fieldTermData == null)
        return results;
      try {
        for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
          var field = _e.value;
          var fieldBoost = fieldBoosts[field];
          var fieldId = this._fieldIds[field];
          var fieldTermFreqs = fieldTermData.get(fieldId);
          if (fieldTermFreqs == null)
            continue;
          var matchingFields = fieldTermFreqs.size;
          var avgFieldLength = this._avgFieldLength[fieldId];
          try {
            for (var _f = (e_25 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
              var docId = _g.value;
              if (!this._documentIds.has(docId)) {
                this.removeTerm(fieldId, docId, derivedTerm);
                matchingFields -= 1;
                continue;
              }
              var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;
              if (!docBoost)
                continue;
              var termFreq = fieldTermFreqs.get(docId);
              var fieldLength = this._fieldLength.get(docId)[fieldId];
              var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
              var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
              var result = results.get(docId);
              if (result) {
                result.score += weightedScore;
                assignUniqueTerm(result.terms, sourceTerm);
                var match = getOwnProperty(result.match, derivedTerm);
                if (match) {
                  match.push(field);
                } else {
                  result.match[derivedTerm] = [field];
                }
              } else {
                results.set(docId, {
                  score: weightedScore,
                  terms: [sourceTerm],
                  match: (_c = {}, _c[derivedTerm] = [field], _c)
                });
              }
            }
          } catch (e_25_1) {
            e_25 = { error: e_25_1 };
          } finally {
            try {
              if (_g && !_g.done && (_b = _f.return))
                _b.call(_f);
            } finally {
              if (e_25)
                throw e_25.error;
            }
          }
        }
      } catch (e_24_1) {
        e_24 = { error: e_24_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a2 = _d.return))
            _a2.call(_d);
        } finally {
          if (e_24)
            throw e_24.error;
        }
      }
      return results;
    };
    MiniSearch2.prototype.addTerm = function(fieldId, documentId, term) {
      var indexData = this._index.fetch(term, createMap);
      var fieldIndex = indexData.get(fieldId);
      if (fieldIndex == null) {
        fieldIndex = /* @__PURE__ */ new Map();
        fieldIndex.set(documentId, 1);
        indexData.set(fieldId, fieldIndex);
      } else {
        var docs2 = fieldIndex.get(documentId);
        fieldIndex.set(documentId, (docs2 || 0) + 1);
      }
    };
    MiniSearch2.prototype.removeTerm = function(fieldId, documentId, term) {
      if (!this._index.has(term)) {
        this.warnDocumentChanged(documentId, fieldId, term);
        return;
      }
      var indexData = this._index.fetch(term, createMap);
      var fieldIndex = indexData.get(fieldId);
      if (fieldIndex == null || fieldIndex.get(documentId) == null) {
        this.warnDocumentChanged(documentId, fieldId, term);
      } else if (fieldIndex.get(documentId) <= 1) {
        if (fieldIndex.size <= 1) {
          indexData.delete(fieldId);
        } else {
          fieldIndex.delete(documentId);
        }
      } else {
        fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
      }
      if (this._index.get(term).size === 0) {
        this._index.delete(term);
      }
    };
    MiniSearch2.prototype.warnDocumentChanged = function(shortDocumentId, fieldId, term) {
      var e_26, _a2;
      try {
        for (var _b = __values(Object.keys(this._fieldIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fieldName = _c.value;
          if (this._fieldIds[fieldName] === fieldId) {
            this._options.logger("warn", "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), ' has changed before removal: term "').concat(term, '" was not present in field "').concat(fieldName, '". Removing a document after it has changed can corrupt the index!'), "version_conflict");
            return;
          }
        }
      } catch (e_26_1) {
        e_26 = { error: e_26_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_26)
            throw e_26.error;
        }
      }
    };
    MiniSearch2.prototype.addDocumentId = function(documentId) {
      var shortDocumentId = this._nextId;
      this._idToShortId.set(documentId, shortDocumentId);
      this._documentIds.set(shortDocumentId, documentId);
      this._documentCount += 1;
      this._nextId += 1;
      return shortDocumentId;
    };
    MiniSearch2.prototype.addFields = function(fields) {
      for (var i2 = 0; i2 < fields.length; i2++) {
        this._fieldIds[fields[i2]] = i2;
      }
    };
    MiniSearch2.prototype.addFieldLength = function(documentId, fieldId, count, length) {
      var fieldLengths = this._fieldLength.get(documentId);
      if (fieldLengths == null)
        this._fieldLength.set(documentId, fieldLengths = []);
      fieldLengths[fieldId] = length;
      var averageFieldLength = this._avgFieldLength[fieldId] || 0;
      var totalFieldLength = averageFieldLength * count + length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);
    };
    MiniSearch2.prototype.removeFieldLength = function(documentId, fieldId, count, length) {
      if (count === 1) {
        this._avgFieldLength[fieldId] = 0;
        return;
      }
      var totalFieldLength = this._avgFieldLength[fieldId] * count - length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);
    };
    MiniSearch2.prototype.saveStoredFields = function(documentId, doc) {
      var e_27, _a2;
      var _b = this._options, storeFields = _b.storeFields, extractField = _b.extractField;
      if (storeFields == null || storeFields.length === 0) {
        return;
      }
      var documentFields = this._storedFields.get(documentId);
      if (documentFields == null)
        this._storedFields.set(documentId, documentFields = {});
      try {
        for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
          var fieldName = storeFields_1_1.value;
          var fieldValue = extractField(doc, fieldName);
          if (fieldValue !== void 0)
            documentFields[fieldName] = fieldValue;
        }
      } catch (e_27_1) {
        e_27 = { error: e_27_1 };
      } finally {
        try {
          if (storeFields_1_1 && !storeFields_1_1.done && (_a2 = storeFields_1.return))
            _a2.call(storeFields_1);
        } finally {
          if (e_27)
            throw e_27.error;
        }
      }
    };
    MiniSearch2.wildcard = Symbol("*");
    return MiniSearch2;
  }()
);
var getOwnProperty = function(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
};
var combinators = (_a = {}, _a[OR] = function(a2, b) {
  var e_28, _a2;
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      var existing = a2.get(docId);
      if (existing == null) {
        a2.set(docId, b.get(docId));
      } else {
        var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
        existing.score = existing.score + score;
        existing.match = Object.assign(existing.match, match);
        assignUniqueTerms(existing.terms, terms);
      }
    }
  } catch (e_28_1) {
    e_28 = { error: e_28_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_28)
        throw e_28.error;
    }
  }
  return a2;
}, _a[AND] = function(a2, b) {
  var e_29, _a2;
  var combined = /* @__PURE__ */ new Map();
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      var existing = a2.get(docId);
      if (existing == null)
        continue;
      var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
      assignUniqueTerms(existing.terms, terms);
      combined.set(docId, {
        score: existing.score + score,
        terms: existing.terms,
        match: Object.assign(existing.match, match)
      });
    }
  } catch (e_29_1) {
    e_29 = { error: e_29_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_29)
        throw e_29.error;
    }
  }
  return combined;
}, _a[AND_NOT] = function(a2, b) {
  var e_30, _a2;
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      a2.delete(docId);
    }
  } catch (e_30_1) {
    e_30 = { error: e_30_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_30)
        throw e_30.error;
    }
  }
  return a2;
}, _a);
var defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };
var calcBM25Score = function(termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
  var k = bm25params.k, b = bm25params.b, d = bm25params.d;
  var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
};
var termToQuerySpec = function(options) {
  return function(term, i2, terms) {
    var fuzzy = typeof options.fuzzy === "function" ? options.fuzzy(term, i2, terms) : options.fuzzy || false;
    var prefix = typeof options.prefix === "function" ? options.prefix(term, i2, terms) : options.prefix === true;
    return { term, fuzzy, prefix };
  };
};
var defaultOptions = {
  idField: "id",
  extractField: function(document2, fieldName) {
    return document2[fieldName];
  },
  tokenize: function(text) {
    return text.split(SPACE_OR_PUNCTUATION);
  },
  processTerm: function(term) {
    return term.toLowerCase();
  },
  fields: void 0,
  searchOptions: void 0,
  storeFields: [],
  logger: function(level, message) {
    if (typeof (console === null || console === void 0 ? void 0 : console[level]) === "function")
      console[level](message);
  },
  autoVacuum: true
};
var defaultSearchOptions = {
  combineWith: OR,
  prefix: false,
  fuzzy: false,
  maxFuzzy: 6,
  boost: {},
  weights: { fuzzy: 0.45, prefix: 0.375 },
  bm25: defaultBM25params
};
var defaultAutoSuggestOptions = {
  combineWith: AND,
  prefix: function(term, i2, terms) {
    return i2 === terms.length - 1;
  }
};
var defaultVacuumOptions = { batchSize: 1e3, batchWait: 10 };
var defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };
var defaultAutoVacuumOptions = __assign(__assign({}, defaultVacuumOptions), defaultVacuumConditions);
var assignUniqueTerm = function(target, term) {
  if (!target.includes(term))
    target.push(term);
};
var assignUniqueTerms = function(target, source) {
  var e_31, _a2;
  try {
    for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
      var term = source_1_1.value;
      if (!target.includes(term))
        target.push(term);
    }
  } catch (e_31_1) {
    e_31 = { error: e_31_1 };
  } finally {
    try {
      if (source_1_1 && !source_1_1.done && (_a2 = source_1.return))
        _a2.call(source_1);
    } finally {
      if (e_31)
        throw e_31.error;
    }
  }
};
var byScore = function(_a2, _b) {
  var a2 = _a2.score;
  var b = _b.score;
  return b - a2;
};
var createMap = function() {
  return /* @__PURE__ */ new Map();
};
var objectToNumericMap = function(object) {
  var e_32, _a2;
  var map = /* @__PURE__ */ new Map();
  try {
    for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      map.set(parseInt(key, 10), object[key]);
    }
  } catch (e_32_1) {
    e_32 = { error: e_32_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_32)
        throw e_32.error;
    }
  }
  return map;
};
var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;
const { div: div$5, input: input$1, button: button$4, a: a$4, span: span$5 } = van.tags;
const Card = (cls, ...content) => {
  return div$5({ class: `tinymist-card ${cls}` }, ...content);
};
const TemplateList = (packages, catState) => {
  const AuthorItem = (author) => {
    const [nameStart, emailRest] = author.split("<");
    const name = nameStart.trim();
    const email = (emailRest == null ? void 0 : emailRest.split(">")[0]) || "";
    if (!email) {
      return span$5({ class: `tinymist-author-plain` }, name);
    }
    const href = email.startsWith("@") ? `https://github.com/${email.slice(1)}` : email.startsWith("https://") ? email : `mailto:${email}`;
    return a$4({ class: `tinymist-author`, href }, name);
  };
  const AuthorList = (authors) => {
    if (authors.length <= 1) {
      return span$5(
        { class: `tinymist-author-container` },
        ...authors.map(AuthorItem)
      );
    }
    return span$5(
      { class: `tinymist-author-container` },
      AuthorItem(authors[0]),
      ", ",
      span$5(
        {
          style: "text-decoration: underline",
          title: authors.slice(1).join(", ")
        },
        "et al."
      )
    );
  };
  const highlightMatches = (text, searchResults) => {
    if (!searchResults || !text)
      return van.tags.span({}, text);
    const searchTerms = searchResults.flatMap((result) => result.queryTerms);
    const regex = new RegExp(`(${searchTerms.join("|")})`, "gi");
    const parts = text.split(regex);
    return van.tags.span({}, ...parts.map(
      (part) => regex.test(part) ? van.tags.span({ class: "tinymist-highlight" }, part) : part
    ));
  };
  const TemplateListItem = (item) => {
    const TemplateAction = (icon, title, onclick) => button$4(
      {
        class: "tinymist-button tinymist-template-action",
        title,
        onclick
      },
      icon
    );
    return Card(
      "template-card",
      div$5(
        a$4(
          { href: item.repository, style: "font-size: 1.2em" },
          () => {
            return highlightMatches(item.name, catState.searchSelected.val);
          }
        ),
        span$5(" "),
        span$5({ style: "font-size: 0.8em" }, "v" + item.version),
        span$5(" by "),
        AuthorList(item.authors)
      ),
      div$5(
        {
          style: "display: flex; align-items: center; gap: 0.25em; margin-top: 0.4em;",
          class: "tinymist-template-actions"
        },
        button$4(
          {
            class: van.derive(() => {
              const activatingCls = catState.getIsFavorite("preview", item.name) ? " activated" : "";
              return "tinymist-button tinymist-template-action" + activatingCls;
            }),
            title: van.derive(
              () => catState.getIsFavorite("preview", item.name) ? "Removes from favorite" : "Adds to favorite"
            ),
            onclick() {
              catState.negIsFavorite("preview", item.name);
            }
          },
          HeartIcon(16)
        ),
        TemplateAction(AddIcon(16), "Creates project", () => {
          const packageSpec = `@preview/${item.name}:${item.version}`;
          requestInitTemplate(packageSpec);
        }),
        // categories
        item.categories.map((cat) => {
          for (const category of CATEGORIES) {
            if (category.value === cat) {
              return category;
            }
          }
          return { value: cat };
        }).map(CategoryButton(catState))
      ),
      div$5({ style: "clear: both" }),
      div$5(
        { style: "margin-top: 0.4em" },
        div$5({}, () => {
          return highlightMatches(item.description, catState.searchSelected.val);
        })
      )
    );
  };
  function runFilterSearch(searchResult) {
    const searchResultMap = new Set(searchResult == null ? void 0 : searchResult.map((result) => result.id));
    return (value) => searchResult === void 0 || searchResultMap.has(value.id);
  }
  function runFilterCategory(categoryFilter) {
    return (value) => {
      if (categoryFilter.has("all")) {
        return true;
      }
      return value.categories.some((cat) => categoryFilter.has(cat));
    };
  }
  function runFilterFavorite(value) {
    if (!catState.filterFavorite.val) {
      return true;
    }
    return catState.getIsFavorite("preview", value.name);
  }
  return div$5(
    (_dom) => div$5(
      packages.val.filter((item) => item.template).filter(runFilterCategory(catState.categories.val)).filter(runFilterFavorite).filter(runFilterSearch(catState.searchSelected.val)).map(TemplateListItem) || []
    )
  );
};
const SearchBar = (packages, catState) => {
  const search = van.derive(() => {
    const search2 = new MiniSearch({
      fields: ["name", "description", "authors", "keywords", "categories"]
    });
    search2.addAll(Object.values(packages.val.filter((item) => item.template)));
    return search2;
  });
  return input$1({
    class: "tinymist-search",
    type: "text",
    placeholder: "Search templates...",
    oninput: (e) => {
      const input2 = e.target;
      if (input2.value === "") {
        catState.searchSelected.val = void 0;
        return;
      }
      const results = search.val.search(input2.value, { prefix: true });
      catState.searchSelected.val = results;
    }
  });
};
class FilterState {
  constructor(packageUserData) {
    __publicField(this, "activating", van.state("all"));
    __publicField(this, "categories", van.state(/* @__PURE__ */ new Set(["all"])));
    __publicField(this, "filterFavorite");
    __publicField(this, "packageUserData");
    __publicField(this, "searchSelected", van.state(void 0));
    this.filterFavorite = van.state(Object.keys(packageUserData).length > 0);
    this.packageUserData = van.state(packageUserData);
  }
  setCategory(category) {
    this.activating.val = category;
    this.categories.val = /* @__PURE__ */ new Set([category]);
  }
  getIsFavorite(namespace, name) {
    var _a2, _b;
    return (_b = (_a2 = this.packageUserData.val[namespace]) == null ? void 0 : _a2[name]) == null ? void 0 : _b.isFavorite;
  }
  negIsFavorite(namespace, name) {
    const thisData = {
      ...this.packageUserData.val
    };
    const ns = thisData[namespace] || (thisData[namespace] = {});
    ns[name] = {
      isFavorite: !this.getIsFavorite(namespace, name)
    };
    this.packageUserData.val = thisData;
    requestSavePackageData(thisData);
  }
}
const CATEGORIES = [
  { value: "all", display: "All" },
  { value: "office", display: "Office" },
  { value: "cv", display: "CV" },
  { value: "presentation", display: "Presentation" },
  { value: "paper", display: "Paper" },
  { value: "book", display: "Book" },
  { value: "fun", display: "For Fun" }
];
const CategoryButton = (catState) => (category) => {
  return button$4(
    {
      class: van.derive(() => {
        const activatingCls = category.value === catState.activating.val ? " activated" : "";
        return "tinymist-button" + activatingCls;
      }),
      title: "Filter by category: " + category.value,
      onclick: () => catState.setCategory(category.value)
    },
    div$5(
      {
        style: "height: 16px;"
      },
      category.display || category.value
    )
  );
};
const FilterRow = (catState) => {
  const favButton = button$4(
    {
      class: van.derive(() => {
        const activatingCls = catState.filterFavorite.val ? " activated" : "";
        return "tinymist-button" + activatingCls;
      }),
      title: "Filter by favorite state",
      onclick: () => catState.filterFavorite.val = !catState.filterFavorite.val
    },
    HeartIcon(16)
  );
  return div$5(
    { class: "tinymist-category-filter" },
    favButton,
    ...CATEGORIES.map(CategoryButton(catState))
  );
};
const TemplateGallery = () => {
  const packages = van.state([]);
  const favoriteState = `{ "touying": { "isFavorite": true } }`;
  const favoritePlaceholders = `:[[preview:FavoritePlaceholder]]:`;
  const catState = new FilterState(
    JSON.parse(
      favoritePlaceholders.startsWith(":") ? favoriteState : base64Decode(favoritePlaceholders)
    )
  );
  van.derive(async () => {
    const rawPackages = await fetch(
      "https://packages.typst.org/preview/index.json"
    ).then((res) => res.json());
    const packagesIndex = /* @__PURE__ */ new Map();
    for (const pkg of rawPackages) {
      const name = pkg.name;
      if (!packagesIndex.has(name)) {
        packagesIndex.set(name, []);
      }
      packagesIndex.get(name).push(pkg);
    }
    const packagesList = Array.from(packagesIndex.entries()).map(([_k, v]) => {
      const versions = v.sort((a2, b) => a2.version.localeCompare(b.version));
      const lastVersion = versions[versions.length - 1];
      return {
        ...lastVersion,
        id: `@preview/${lastVersion.name}`,
        versions
      };
    });
    packages.val = packagesList;
  });
  return div$5(
    SearchBar(packages, catState),
    FilterRow(catState),
    TemplateList(packages, catState)
  );
};
const { button: button$3 } = van.tags;
function startModal(...contents) {
  const shadow = document.createElement("div");
  shadow.style.position = "fixed";
  shadow.style.top = "0";
  shadow.style.left = "0";
  shadow.style.width = "100%";
  shadow.style.height = "100%";
  shadow.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
  shadow.style.zIndex = "1000";
  document.body.appendChild(shadow);
  const floatingWindow = document.createElement("div");
  floatingWindow.classList.add("tinymist-window");
  floatingWindow.style.position = "fixed";
  floatingWindow.style.top = "50%";
  floatingWindow.style.left = "50%";
  floatingWindow.style.transform = "translate(-50%, -50%)";
  floatingWindow.style.width = "80%";
  floatingWindow.style.maxWidth = "800px";
  floatingWindow.style.height = "80%";
  floatingWindow.style.maxHeight = "600px";
  floatingWindow.style.backgroundColor = "var(--modal-background)";
  floatingWindow.style.padding = "1rem";
  floatingWindow.style.overflow = "auto";
  floatingWindow.style.zIndex = "1001";
  floatingWindow.style.borderRadius = "6px";
  const close = button$3(
    {
      class: "tinymist-button"
    },
    "Close"
  );
  const keydownHandler = (e) => {
    if (e.key === "Escape" || e.key === " " || e.key === "Enter") {
      removeModal();
    }
  };
  const removeModal = () => {
    document.body.removeChild(shadow);
    document.body.removeChild(floatingWindow);
    window.removeEventListener("keydown", keydownHandler);
  };
  close.onclick = removeModal;
  window.addEventListener("keydown", keydownHandler);
  floatingWindow.appendChild(close);
  const help = button$3(
    {
      class: "tinymist-button",
      style: "margin-left: 0.5em",
      title: "Click the close button or press esc/space/enter to close this window"
    },
    "Help"
  );
  help.onclick = () => {
    alert(
      "Click the close button or press esc/space/enter to close this window"
    );
  };
  floatingWindow.appendChild(help);
  for (const content of contents) {
    floatingWindow.appendChild(content);
  }
  document.body.appendChild(floatingWindow);
}
const { div: div$4, h2: h2$1, button: button$2, iframe, code: code$4, br: br$3, span: span$4 } = van.tags;
const ORIGIN = "https://ui.perfetto.dev";
const openTrace = (arrayBuffer, traceUrl) => {
  let subWindow = document.getElementById("perfetto");
  subWindow.src = ORIGIN;
  subWindow.style.display = "block";
  subWindow.style.width = "100%";
  subWindow.style.height = "100vh";
  let handle = subWindow.contentWindow;
  const btnFetch = document.getElementById("open-trace");
  if (!handle) {
    btnFetch.classList.add("warning");
    btnFetch.onclick = () => openTrace(arrayBuffer);
    console.log("Popups blocked, you need to manually click the button");
    btnFetch.innerText = "Popups blocked, click here to open the trace file";
    return;
  }
  const timer = setInterval(() => handle.postMessage("PING", ORIGIN), 50);
  const onMessageHandler = (evt) => {
    if (evt.data !== "PONG")
      return;
    window.clearInterval(timer);
    window.removeEventListener("message", onMessageHandler);
    const reopenUrl = new URL(location.href);
    if (traceUrl) {
      reopenUrl.hash = `#reopen=${traceUrl}`;
    }
    handle.postMessage(
      {
        perfetto: {
          buffer: arrayBuffer,
          title: "Typst Tracing",
          url: reopenUrl.toString()
        }
      },
      ORIGIN
    );
  };
  window.addEventListener("message", onMessageHandler);
};
const enc = new TextEncoder();
const Tracing = () => {
  var _a2;
  (_a2 = document.getElementById("tinymist-app")) == null ? void 0 : _a2.classList.add("no-wrap");
  const mainWindow = div$4(
    {
      class: "flex-col tinymist-main-window",
      style: "justify-content: center;align-items: center;"
    },
    div$4(
      {
        id: "message",
        style: "flex: auto"
      },
      "Collecting trace..."
    ),
    button$2({
      id: "open-trace",
      class: "tinymist-button",
      style: "display: none; flex: auto"
    })
  );
  const since = Date.now();
  const collecting = setInterval(async () => {
    const message = document.getElementById("message");
    if (!message) {
      return;
    }
    const elapsed = Date.now() - since;
    const elapsedAlign = (elapsed / 1e3).toFixed(1).padStart(5, " ");
    if (traceData.val) {
      clearInterval(collecting);
      const openTraceButton = document.getElementById(
        "open-trace"
      );
      openTraceButton.style.display = "block";
      const rep = traceData.val;
      const firstResponse = rep.messages.find(
        (msg2) => "id" in msg2 && msg2.id === 0
      );
      const diagnosticsMessage = rep.messages.find(
        (msg2) => "method" in msg2 && msg2.method === "tinymistExt/diagnostics"
      );
      let msg;
      let tracingContent = void 0;
      if (!firstResponse) {
        msg = "No trace data found";
      } else if (firstResponse.error) {
        msg = `Error: ${firstResponse.error.message}`;
      } else {
        msg = "";
        if (firstResponse.result.tracingData) {
          tracingContent = enc.encode(firstResponse.result.tracingData).buffer;
        } else if (firstResponse.result.tracingUrl) {
          const response = await fetch(firstResponse.result.tracingUrl);
          tracingContent = await response.arrayBuffer();
        } else {
          msg = "No trace data or url found in response";
        }
      }
      if (!firstResponse) {
        message.innerText = "No response found";
        return;
      }
      message.innerText = "";
      mainWindow.style.display = "none";
      startModal(
        div$4(
          { style: "margin: 1em 0" },
          ...msg.length > 0 ? [code$4(msg), br$3()] : [],
          "Run ",
          diffPath(rep.request.root, rep.request.main),
          " using ",
          shortProgram(rep.request.compilerProgram),
          " in ",
          elapsedAlign.trim(),
          "s, with ",
          code$4(
            {
              title: base64Decode(rep.stderr),
              style: "text-decoration: underline"
            },
            "logging"
          ),
          ".",
          optionalInputs(rep.request.inputs),
          optionalFontPaths(rep.request.fontPaths)
        ),
        diagReport(diagnosticsMessage == null ? void 0 : diagnosticsMessage.params)
      );
      if (tracingContent) {
        openTrace(tracingContent);
      }
      return;
    }
    message.innerText = `Collecting trace... ${elapsedAlign}s`;
  }, 100);
  return div$4(
    mainWindow,
    iframe({
      id: "perfetto",
      style: "display: none; flex: auto; border: none;"
      // sandbox: "allow-same-origin",
    })
  );
};
function diffPath(root, main) {
  if (main.startsWith(root))
    ;
  main = main.slice(root.length);
  return code$4(
    code$4({ style: "color: #2486b9; text-decoration: underline" }, root),
    code$4({ style: "color: #8cc269; text-decoration: underline" }, main)
  );
}
function shortProgram(compilerProgram) {
  let lastPath = compilerProgram.split(/[\/\\]/g).pop();
  if (lastPath) {
    lastPath = lastPath.replace(/\.[^.]*$/, "");
    return code$4(
      { title: compilerProgram, style: "text-decoration: underline" },
      lastPath
    );
  }
}
function optionalInputs(inputs) {
  if (inputs == null ? void 0 : inputs.length) {
    return div$4("Inputs: ", code$4(JSON.stringify(inputs)));
  }
  return div$4();
}
function optionalFontPaths(fontPaths) {
  if (fontPaths == null ? void 0 : fontPaths.length) {
    return code$4("Font paths: ", code$4(JSON.stringify(fontPaths)));
  }
  return div$4();
}
function diagReport(diagnostics) {
  if (!diagnostics || !Object.values(diagnostics).map((d) => (d == null ? void 0 : d.length) || 0).some((l) => l > 0)) {
    return div$4();
  }
  const diagDivs = [];
  for (const [path, diags] of Object.entries(diagnostics)) {
    if (diags.length === 0) {
      continue;
    }
    const pathDiv = div$4(
      code$4(
        { style: "text-decoration: underline", title: path },
        path.split(/[\/\\]/g).pop()
      )
    );
    const diagPre = div$4(
      diags.map(
        (d, i2) => div$4(
          { style: "margin: 0.5em" },
          ...i2 ? [
            div$4({
              style: "border-top: 1px solid currentColor; margin: 0.5em 0"
            })
          ] : [],
          span$4(
            span$4(`${d.range.start.line}:${d.range.start.character}`),
            "-",
            span$4(`${d.range.end.line}:${d.range.end.character}`),
            " ",
            d.message,
            "\n"
          )
        )
      )
    );
    diagDivs.push(div$4(pathDiv, diagPre));
  }
  return div$4(
    { style: "margin-top: 1.5em" },
    h2$1({ style: "margin: 0.4em 0" }, "Diagnostics"),
    ...diagDivs
  );
}
var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var inited = false;
function init() {
  inited = true;
  var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i2 = 0, len = code2.length; i2 < len; ++i2) {
    lookup[i2] = code2[i2];
    revLookup[code2.charCodeAt(i2)] = i2;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i2, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i2 = 0, j = 0; i2 < l; i2 += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16) + (uint8[i2 + 1] << 8) + uint8[i2 + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i2];
  i2 += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i2], i2 += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i2 - d] |= s * 128;
}
var toString = {}.toString;
var isArray = Array.isArray || function(arr) {
  return toString.call(arr) == "[object Array]";
};
var INSPECT_MAX_BYTES = 50;
Buffer2.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== void 0 ? global$1.TYPED_ARRAY_SUPPORT : true;
kMaxLength();
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
Buffer2.poolSize = 8192;
Buffer2._augment = function(arr) {
  arr.__proto__ = Buffer2.prototype;
  return arr;
};
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
Buffer2.from = function(value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};
if (Buffer2.TYPED_ARRAY_SUPPORT) {
  Buffer2.prototype.__proto__ = Uint8Array.prototype;
  Buffer2.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2)
    ;
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
Buffer2.alloc = function(size, fill2, encoding) {
  return alloc(null, size, fill2, encoding);
};
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size; ++i2) {
      that[i2] = 0;
    }
  }
  return that;
}
Buffer2.allocUnsafe = function(size) {
  return allocUnsafe(null, size);
};
Buffer2.allocUnsafeSlow = function(size) {
  return allocUnsafe(null, size);
};
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    that[i2] = array[i2] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
Buffer2.isBuffer = isBuffer;
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
Buffer2.compare = function compare(a2, b) {
  if (!internalIsBuffer(a2) || !internalIsBuffer(b)) {
    throw new TypeError("Arguments must be Buffers");
  }
  if (a2 === b)
    return 0;
  var x = a2.length;
  var y = b.length;
  for (var i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
    if (a2[i2] !== b[i2]) {
      x = a2[i2];
      y = b[i2];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
Buffer2.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
};
Buffer2.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer2.alloc(0);
  }
  var i2;
  if (length === void 0) {
    length = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length += list[i2].length;
    }
  }
  var buffer = Buffer2.allocUnsafe(length);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer2.prototype._isBuffer = true;
function swap(b, n, m) {
  var i2 = b[n];
  b[n] = b[m];
  b[m] = i2;
}
Buffer2.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 2) {
    swap(this, i2, i2 + 1);
  }
  return this;
};
Buffer2.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 4) {
    swap(this, i2, i2 + 3);
    swap(this, i2 + 1, i2 + 2);
  }
  return this;
};
Buffer2.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  }
  for (var i2 = 0; i2 < len; i2 += 8) {
    swap(this, i2, i2 + 7);
    swap(this, i2 + 1, i2 + 6);
    swap(this, i2 + 2, i2 + 5);
    swap(this, i2 + 3, i2 + 4);
  }
  return this;
};
Buffer2.prototype.toString = function toString2() {
  var length = this.length | 0;
  if (length === 0)
    return "";
  if (arguments.length === 0)
    return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer2.prototype.equals = function equals(b) {
  if (!internalIsBuffer(b))
    throw new TypeError("Argument must be a Buffer");
  if (this === b)
    return true;
  return Buffer2.compare(this, b) === 0;
};
Buffer2.prototype.inspect = function inspect() {
  var str = "";
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
    if (this.length > max)
      str += " ... ";
  }
  return "<Buffer " + str + ">";
};
Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError("Argument must be a Buffer");
  }
  if (start === void 0) {
    start = 0;
  }
  if (end === void 0) {
    end = target ? target.length : 0;
  }
  if (thisStart === void 0) {
    thisStart = 0;
  }
  if (thisEnd === void 0) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError("out of range index");
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target)
    return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i2 = 0; i2 < len; ++i2) {
    if (thisCopy[i2] !== targetCopy[i2]) {
      x = thisCopy[i2];
      y = targetCopy[i2];
      break;
    }
  }
  if (x < y)
    return -1;
  if (y < x)
    return 1;
  return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i3) {
    if (indexSize === 1) {
      return buf[i3];
    } else {
      return buf.readUInt16BE(i3 * indexSize);
    }
  }
  var i2;
  if (dir) {
    var foundIndex = -1;
    for (i2 = byteOffset; i2 < arrLength; i2++) {
      if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i2;
        if (i2 - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i2 -= i2 - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i2 = byteOffset; i2 >= 0; i2--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i2 + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i2;
    }
  }
  return -1;
}
Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i2 = 0; i2 < length; ++i2) {
    var parsed = parseInt(string.substr(i2 * 2, 2), 16);
    if (isNaN(parsed))
      return i2;
    buf[offset + i2] = parsed;
  }
  return i2;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer2.prototype.write = function write2(string, offset, length, encoding) {
  if (offset === void 0) {
    encoding = "utf8";
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    encoding = offset;
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === void 0)
        encoding = "utf8";
    } else {
      encoding = length;
      length = void 0;
    }
  } else {
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  if (!encoding)
    encoding = "utf8";
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "hex":
        return hexWrite(this, string, offset, length);
      case "utf8":
      case "utf-8":
        return utf8Write(this, string, offset, length);
      case "ascii":
        return asciiWrite(this, string, offset, length);
      case "latin1":
      case "binary":
        return latin1Write(this, string, offset, length);
      case "base64":
        return base64Write(this, string, offset, length);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer2.prototype.toJSON = function toJSON() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i2 = start;
  while (i2 < end) {
    var firstByte = buf[i2];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i2 + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i2 + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i2 + 1];
          thirdByte = buf[i2 + 2];
          fourthByte = buf[i2 + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i2 += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
var MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i2 = 0;
  while (i2 < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i2 = start; i2 < end; ++i2) {
    ret += String.fromCharCode(buf[i2]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i2 = start; i2 < end; ++i2) {
    out += toHex(buf[i2]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i2 = 0; i2 < bytes.length; i2 += 2) {
    res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
  }
  return res;
}
Buffer2.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === void 0 ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0)
      end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer2.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer2(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  return val;
};
Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength2, this.length);
  }
  var val = this[offset + --byteLength2];
  var mul = 1;
  while (byteLength2 > 0 && (mul *= 256)) {
    val += this[offset + --byteLength2] * mul;
  }
  return val;
};
Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var val = this[offset];
  var mul = 1;
  var i2 = 0;
  while (++i2 < byteLength2 && (mul *= 256)) {
    val += this[offset + i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert)
    checkOffset(offset, byteLength2, this.length);
  var i2 = byteLength2;
  var mul = 1;
  var val = this[offset + --i2];
  while (i2 > 0 && (mul *= 256)) {
    val += this[offset + --i2] * mul;
  }
  mul *= 128;
  if (val >= mul)
    val -= Math.pow(2, 8 * byteLength2);
  return val;
};
Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length);
  if (!(this[offset] & 128))
    return this[offset];
  return (255 - this[offset] + 1) * -1;
};
Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 32768 ? val | 4294901760 : val;
};
Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4);
};
Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4);
};
Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8);
};
Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var mul = 1;
  var i2 = 0;
  this[offset] = value & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    this[offset + i2] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength2 = byteLength2 | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
    checkInt(this, value, offset, byteLength2, maxBytes, 0);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  this[offset + i2] = value & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    this[offset + i2] = value / mul & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 255, 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  this[offset] = value & 255;
  return offset + 1;
};
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
    buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
  }
}
Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 65535, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
    buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
  }
}
Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 4294967295, 0);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 255;
  while (++i2 < byteLength2 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength2 - 1);
    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
  }
  var i2 = byteLength2 - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i2] = value & 255;
  while (--i2 >= 0 && (mul *= 256)) {
    if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
      sub = 1;
    }
    this[offset + i2] = (value / mul >> 0) - sub & 255;
  }
  return offset + byteLength2;
};
Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 1, 127, -128);
  if (!Buffer2.TYPED_ARRAY_SUPPORT)
    value = Math.floor(value);
  if (value < 0)
    value = 255 + value + 1;
  this[offset] = value & 255;
  return offset + 1;
};
Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};
Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 2, 32767, -32768);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};
Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};
Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert)
    checkInt(this, value, offset, 4, 2147483647, -2147483648);
  if (value < 0)
    value = 4294967295 + value + 1;
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};
Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }
  return len;
};
Buffer2.prototype.fill = function fill(val, start, end, encoding) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
    if (encoding !== void 0 && typeof encoding !== "string") {
      throw new TypeError("encoding must be a string");
    }
    if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
    var len = bytes.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes[i2 % len];
    }
  }
  return this;
};
var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(
        codePoint >> 6 | 192,
        codePoint & 63 | 128
      );
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(
        codePoint >> 12 | 224,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(
        codePoint >> 18 | 240,
        codePoint >> 12 & 63 | 128,
        codePoint >> 6 & 63 | 128,
        codePoint & 63 | 128
      );
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    byteArray.push(str.charCodeAt(i2) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i2 = 0; i2 < str.length; ++i2) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i2);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src.length)
      break;
    dst[i2 + offset] = src[i2];
  }
  return i2;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
const charCodeOfDot = ".".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const getTag = function(value) {
  return Object.prototype.toString.call(value);
};
const isSymbol = function(value) {
  const type = typeof value;
  return type === "symbol" || type === "object" && value && getTag(value) === "[object Symbol]";
};
const isKey = function(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  const type = typeof value;
  if (type === "number" || type === "symbol" || type === "boolean" || !value || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
};
const stringToPath = function(string) {
  const result = [];
  if (string.charCodeAt(0) === charCodeOfDot) {
    result.push("");
  }
  string.replace(rePropName, function(match, expression, quote, subString) {
    let key = match;
    if (quote) {
      key = subString.replace(reEscapeChar, "$1");
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
  });
  return result;
};
const castPath = function(value, object) {
  if (Array.isArray(value)) {
    return value;
  } else {
    return isKey(value, object) ? [value] : stringToPath(value);
  }
};
const toKey = function(value) {
  if (typeof value === "string" || isSymbol(value))
    return value;
  const result = `${value}`;
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
};
const get = function(object, path) {
  path = castPath(path, object);
  let index = 0;
  const length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index === length ? object : void 0;
};
const is_object = function(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
};
const normalize_columns = function(columns) {
  if (columns === void 0 || columns === null) {
    return [void 0, void 0];
  }
  if (typeof columns !== "object") {
    return [Error('Invalid option "columns": expect an array or an object')];
  }
  if (!Array.isArray(columns)) {
    const newcolumns = [];
    for (const k in columns) {
      newcolumns.push({
        key: k,
        header: columns[k]
      });
    }
    columns = newcolumns;
  } else {
    const newcolumns = [];
    for (const column of columns) {
      if (typeof column === "string") {
        newcolumns.push({
          key: column,
          header: column
        });
      } else if (typeof column === "object" && column !== null && !Array.isArray(column)) {
        if (!column.key) {
          return [Error('Invalid column definition: property "key" is required')];
        }
        if (column.header === void 0) {
          column.header = column.key;
        }
        newcolumns.push(column);
      } else {
        return [Error("Invalid column definition: expect a string or an object")];
      }
    }
    columns = newcolumns;
  }
  return [void 0, columns];
};
class CsvError extends Error {
  constructor(code2, message, ...contexts) {
    if (Array.isArray(message))
      message = message.join(" ");
    super(message);
    if (Error.captureStackTrace !== void 0) {
      Error.captureStackTrace(this, CsvError);
    }
    this.code = code2;
    for (const context of contexts) {
      for (const key in context) {
        const value = context[key];
        this[key] = isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));
      }
    }
  }
}
const underscore = function(str) {
  return str.replace(/([A-Z])/g, function(_, match) {
    return "_" + match.toLowerCase();
  });
};
const normalize_options = function(opts) {
  const options = {};
  for (const opt in opts) {
    options[underscore(opt)] = opts[opt];
  }
  if (options.bom === void 0 || options.bom === null || options.bom === false) {
    options.bom = false;
  } else if (options.bom !== true) {
    return [new CsvError("CSV_OPTION_BOOLEAN_INVALID_TYPE", [
      "option `bom` is optional and must be a boolean value,",
      `got ${JSON.stringify(options.bom)}`
    ])];
  }
  if (options.delimiter === void 0 || options.delimiter === null) {
    options.delimiter = ",";
  } else if (isBuffer(options.delimiter)) {
    options.delimiter = options.delimiter.toString();
  } else if (typeof options.delimiter !== "string") {
    return [new CsvError("CSV_OPTION_DELIMITER_INVALID_TYPE", [
      "option `delimiter` must be a buffer or a string,",
      `got ${JSON.stringify(options.delimiter)}`
    ])];
  }
  if (options.quote === void 0 || options.quote === null) {
    options.quote = '"';
  } else if (options.quote === true) {
    options.quote = '"';
  } else if (options.quote === false) {
    options.quote = "";
  } else if (isBuffer(options.quote)) {
    options.quote = options.quote.toString();
  } else if (typeof options.quote !== "string") {
    return [new CsvError("CSV_OPTION_QUOTE_INVALID_TYPE", [
      "option `quote` must be a boolean, a buffer or a string,",
      `got ${JSON.stringify(options.quote)}`
    ])];
  }
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  }
  if (options.escape_formulas === void 0 || options.escape_formulas === null) {
    options.escape_formulas = false;
  } else if (typeof options.escape_formulas !== "boolean") {
    return [new CsvError("CSV_OPTION_ESCAPE_FORMULAS_INVALID_TYPE", [
      "option `escape_formulas` must be a boolean,",
      `got ${JSON.stringify(options.escape_formulas)}`
    ])];
  }
  if (options.quoted_empty === void 0 || options.quoted_empty === null) {
    options.quoted_empty = void 0;
  }
  if (options.quoted_match === void 0 || options.quoted_match === null || options.quoted_match === false) {
    options.quoted_match = null;
  } else if (!Array.isArray(options.quoted_match)) {
    options.quoted_match = [options.quoted_match];
  }
  if (options.quoted_match) {
    for (const quoted_match of options.quoted_match) {
      const isString = typeof quoted_match === "string";
      const isRegExp = quoted_match instanceof RegExp;
      if (!isString && !isRegExp) {
        return [Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)];
      }
    }
  }
  if (options.quoted_string === void 0 || options.quoted_string === null) {
    options.quoted_string = false;
  }
  if (options.eof === void 0 || options.eof === null) {
    options.eof = true;
  }
  if (options.escape === void 0 || options.escape === null) {
    options.escape = '"';
  } else if (isBuffer(options.escape)) {
    options.escape = options.escape.toString();
  } else if (typeof options.escape !== "string") {
    return [Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)];
  }
  if (options.escape.length > 1) {
    return [Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)];
  }
  if (options.header === void 0 || options.header === null) {
    options.header = false;
  }
  const [errColumns, columns] = normalize_columns(options.columns);
  if (errColumns !== void 0)
    return [errColumns];
  options.columns = columns;
  if (options.quoted === void 0 || options.quoted === null) {
    options.quoted = false;
  }
  if (options.cast === void 0 || options.cast === null) {
    options.cast = {};
  }
  if (options.cast.bigint === void 0 || options.cast.bigint === null) {
    options.cast.bigint = (value) => "" + value;
  }
  if (options.cast.boolean === void 0 || options.cast.boolean === null) {
    options.cast.boolean = (value) => value ? "1" : "";
  }
  if (options.cast.date === void 0 || options.cast.date === null) {
    options.cast.date = (value) => "" + value.getTime();
  }
  if (options.cast.number === void 0 || options.cast.number === null) {
    options.cast.number = (value) => "" + value;
  }
  if (options.cast.object === void 0 || options.cast.object === null) {
    options.cast.object = (value) => JSON.stringify(value);
  }
  if (options.cast.string === void 0 || options.cast.string === null) {
    options.cast.string = function(value) {
      return value;
    };
  }
  if (options.on_record !== void 0 && typeof options.on_record !== "function") {
    return [Error(`Invalid Option: "on_record" must be a function.`)];
  }
  if (options.record_delimiter === void 0 || options.record_delimiter === null) {
    options.record_delimiter = "\n";
  } else if (isBuffer(options.record_delimiter)) {
    options.record_delimiter = options.record_delimiter.toString();
  } else if (typeof options.record_delimiter !== "string") {
    return [Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)];
  }
  switch (options.record_delimiter) {
    case "unix":
      options.record_delimiter = "\n";
      break;
    case "mac":
      options.record_delimiter = "\r";
      break;
    case "windows":
      options.record_delimiter = "\r\n";
      break;
    case "ascii":
      options.record_delimiter = "";
      break;
    case "unicode":
      options.record_delimiter = "\u2028";
      break;
  }
  return [void 0, options];
};
const bom_utf8 = Buffer2.from([239, 187, 191]);
const stringifier = function(options, state2, info) {
  return {
    options,
    state: state2,
    info,
    __transform: function(chunk, push) {
      if (!Array.isArray(chunk) && typeof chunk !== "object") {
        return Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`);
      }
      if (this.info.records === 0) {
        if (Array.isArray(chunk)) {
          if (this.options.header === true && this.options.columns === void 0) {
            return Error("Undiscoverable Columns: header option requires column option or object records");
          }
        } else if (this.options.columns === void 0) {
          const [err2, columns] = normalize_columns(Object.keys(chunk));
          if (err2)
            return;
          this.options.columns = columns;
        }
      }
      if (this.info.records === 0) {
        this.bom(push);
        const err2 = this.headers(push);
        if (err2)
          return err2;
      }
      try {
        if (this.options.on_record) {
          this.options.on_record(chunk, this.info.records);
        }
      } catch (err2) {
        return err2;
      }
      let err, chunk_string;
      if (this.options.eof) {
        [err, chunk_string] = this.stringify(chunk);
        if (err)
          return err;
        if (chunk_string === void 0) {
          return;
        } else {
          chunk_string = chunk_string + this.options.record_delimiter;
        }
      } else {
        [err, chunk_string] = this.stringify(chunk);
        if (err)
          return err;
        if (chunk_string === void 0) {
          return;
        } else {
          if (this.options.header || this.info.records) {
            chunk_string = this.options.record_delimiter + chunk_string;
          }
        }
      }
      this.info.records++;
      push(chunk_string);
    },
    stringify: function(chunk, chunkIsHeader = false) {
      if (typeof chunk !== "object") {
        return [void 0, chunk];
      }
      const { columns } = this.options;
      const record = [];
      if (Array.isArray(chunk)) {
        if (columns) {
          chunk.splice(columns.length);
        }
        for (let i2 = 0; i2 < chunk.length; i2++) {
          const field = chunk[i2];
          const [err, value] = this.__cast(field, {
            index: i2,
            column: i2,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err)
            return [err];
          record[i2] = [value, field];
        }
      } else {
        for (let i2 = 0; i2 < columns.length; i2++) {
          const field = get(chunk, columns[i2].key);
          const [err, value] = this.__cast(field, {
            index: i2,
            column: columns[i2].key,
            records: this.info.records,
            header: chunkIsHeader
          });
          if (err)
            return [err];
          record[i2] = [value, field];
        }
      }
      let csvrecord = "";
      for (let i2 = 0; i2 < record.length; i2++) {
        let options2, err;
        let [value, field] = record[i2];
        if (typeof value === "string") {
          options2 = this.options;
        } else if (is_object(value)) {
          options2 = value;
          value = options2.value;
          delete options2.value;
          if (typeof value !== "string" && value !== void 0 && value !== null) {
            if (err)
              return [Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`)];
          }
          options2 = { ...this.options, ...options2 };
          [err, options2] = normalize_options(options2);
          if (err !== void 0) {
            return [err];
          }
        } else if (value === void 0 || value === null) {
          options2 = this.options;
        } else {
          return [Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`)];
        }
        const { delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter, escape_formulas } = options2;
        if ("" === value && "" === field) {
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          const shouldQuote = quotedMatch || true === quoted_empty || true === quoted_string && false !== quoted_empty;
          if (shouldQuote === true) {
            value = quote + value + quote;
          }
          csvrecord += value;
        } else if (value) {
          if (typeof value !== "string") {
            return [Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`)];
          }
          const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;
          const containsQuote = quote !== "" && value.indexOf(quote) >= 0;
          const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;
          const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;
          const quotedString = quoted_string && typeof field === "string";
          let quotedMatch = quoted_match && quoted_match.filter((quoted_match2) => {
            if (typeof quoted_match2 === "string") {
              return value.indexOf(quoted_match2) !== -1;
            } else {
              return quoted_match2.test(value);
            }
          });
          quotedMatch = quotedMatch && quotedMatch.length > 0;
          if (escape_formulas) {
            switch (value[0]) {
              case "=":
              case "+":
              case "-":
              case "@":
              case "	":
              case "\r":
              case "＝":
              case "＋":
              case "－":
              case "＠":
                value = `'${value}`;
                break;
            }
          }
          const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;
          if (shouldQuote === true && containsEscape === true) {
            const regexp = escape === "\\" ? new RegExp(escape + escape, "g") : new RegExp(escape, "g");
            value = value.replace(regexp, escape + escape);
          }
          if (containsQuote === true) {
            const regexp = new RegExp(quote, "g");
            value = value.replace(regexp, escape + quote);
          }
          if (shouldQuote === true) {
            value = quote + value + quote;
          }
          csvrecord += value;
        } else if (quoted_empty === true || field === "" && quoted_string === true && quoted_empty !== false) {
          csvrecord += quote + quote;
        }
        if (i2 !== record.length - 1) {
          csvrecord += delimiter;
        }
      }
      return [void 0, csvrecord];
    },
    bom: function(push) {
      if (this.options.bom !== true) {
        return;
      }
      push(bom_utf8);
    },
    headers: function(push) {
      if (this.options.header === false) {
        return;
      }
      if (this.options.columns === void 0) {
        return;
      }
      let err;
      let headers = this.options.columns.map((column) => column.header);
      if (this.options.eof) {
        [err, headers] = this.stringify(headers, true);
        headers += this.options.record_delimiter;
      } else {
        [err, headers] = this.stringify(headers);
      }
      if (err)
        return err;
      push(headers);
    },
    __cast: function(value, context) {
      const type = typeof value;
      try {
        if (type === "string") {
          return [void 0, this.options.cast.string(value, context)];
        } else if (type === "bigint") {
          return [void 0, this.options.cast.bigint(value, context)];
        } else if (type === "number") {
          return [void 0, this.options.cast.number(value, context)];
        } else if (type === "boolean") {
          return [void 0, this.options.cast.boolean(value, context)];
        } else if (value instanceof Date) {
          return [void 0, this.options.cast.date(value, context)];
        } else if (type === "object" && value !== null) {
          return [void 0, this.options.cast.object(value, context)];
        } else {
          return [void 0, value, value];
        }
      } catch (err) {
        return [err];
      }
    }
  };
};
const stringify = function(records, opts = {}) {
  const data = [];
  const [err, options] = normalize_options(opts);
  if (err !== void 0)
    throw err;
  const state2 = {
    stop: false
  };
  const info = {
    records: 0
  };
  const api = stringifier(options, state2, info);
  for (const record of records) {
    const err2 = api.__transform(record, function(record2) {
      data.push(record2);
    });
    if (err2 !== void 0)
      throw err2;
  }
  if (data.length === 0) {
    api.bom((d) => {
      data.push(d);
    });
    const err2 = api.headers((headers) => {
      data.push(headers);
    });
    if (err2 !== void 0)
      throw err2;
  }
  return data.join("");
};
function almost(value, target, threshold = 0.01) {
  return Math.abs(value - target) < threshold;
}
function humanStyle(style2) {
  if (!style2) {
    return "Regular";
  }
  if (style2 === "italic") {
    return "Italic";
  }
  if (style2 === "oblique") {
    return "Oblique";
  }
  return `Style ${style2}`;
}
function humanWeightBase(weight) {
  if (!weight) {
    return "Regular";
  }
  if (almost(weight, 100)) {
    return "Thin";
  }
  if (almost(weight, 200)) {
    return "Extra Light";
  }
  if (almost(weight, 300)) {
    return "Light";
  }
  if (almost(weight, 400)) {
    return "Regular";
  }
  if (almost(weight, 500)) {
    return "Medium";
  }
  if (almost(weight, 600)) {
    return "Semibold";
  }
  if (almost(weight, 700)) {
    return "Bold";
  }
  if (almost(weight, 800)) {
    return "Extra Bold";
  }
  if (almost(weight, 900)) {
    return "Black";
  }
  return "";
}
function humanWeight(weight, opts) {
  const base = humanWeightBase(weight);
  if (!base) {
    return `Weight ${weight}`;
  }
  if (!(opts == null ? void 0 : opts.showNumber)) {
    return base;
  }
  return `${base} (${weight})`;
}
function humanStretchBase(stretch) {
  if (!stretch) {
    return "Normal";
  }
  if (almost(stretch, 500)) {
    return "Ultra-condensed";
  }
  if (almost(stretch, 625)) {
    return "Extra-condensed";
  }
  if (almost(stretch, 750)) {
    return "Condensed";
  }
  if (almost(stretch, 875)) {
    return "Semi-condensed";
  }
  if (almost(stretch, 1e3)) {
    return "Normal";
  }
  if (almost(stretch, 1125)) {
    return "Semi-expanded";
  }
  if (almost(stretch, 1250)) {
    return "Expanded";
  }
  if (almost(stretch, 1500)) {
    return "Extra-expanded";
  }
  if (almost(stretch, 2e3)) {
    return "Ultra-expanded";
  }
  return "";
}
function humanStretch(stretch, opts) {
  const base = humanStretchBase(stretch);
  if (!base) {
    return `Stretch ${stretch}`;
  }
  if (!(opts == null ? void 0 : opts.showNumber)) {
    return base;
  }
  return `${base} (${stretch})`;
}
const { div: div$3, a: a$3, span: span$3, code: code$3, br: br$2, button: button$1, form, textarea, label, input } = van.tags;
const Summary = () => {
  const documentMetricsData = `:[[preview:DocumentMetrics]]:`;
  const docMetrics = van.state(
    documentMetricsData.startsWith(":") ? DOC_MOCK$1 : JSON.parse(base64Decode(documentMetricsData))
  );
  console.log("docMetrics", docMetrics);
  const serverInfoData = `:[[preview:ServerInfo]]:`;
  const serverInfos = van.state(
    serverInfoData.startsWith(":") ? SERVER_INFO_MOCK : JSON.parse(base64Decode(serverInfoData))
  );
  console.log("serverInfos", serverInfos);
  const FontSlot = (font) => {
    let fontName;
    if (typeof font.source === "number") {
      let w = docMetrics.val.spanInfo.sources[font.source];
      let title;
      if (w.kind === "fs") {
        title = w.path;
        fontName = a$3(
          {
            style: "font-size: 1.2em; text-decoration: underline; cursor: pointer;",
            title,
            onclick() {
              if (w.kind === "fs") {
                requestRevealPath(w.path);
              }
            }
          },
          font.name
        );
      } else {
        title = `Embedded: ${w.name}`;
        fontName = span$3(
          {
            style: "font-size: 1.2em",
            title
          },
          font.name
        );
      }
    } else {
      fontName = a$3({ style: "font-size: 1.2em" }, font.name);
    }
    return div$3(
      { style: "margin: 1.2em; margin-left: 0.5em" },
      fontName,
      " has ",
      font.usesScale,
      " use(s).",
      br$2(),
      code$3("Variant"),
      ": ",
      code$3(
        font.style === "normal" || !font.style ? "" : `${humanStyle(font.style)}, `,
        span$3(
          { title: `Weight ${font.weight || 400}` },
          `${humanWeight(font.weight)} Weight`
        ),
        ", ",
        span$3(
          { title: `Stretch ${(font.stretch || 1e3) / 10}%` },
          `${humanStretch(font.stretch)} Stretch`
        )
      ),
      br$2(),
      code$3("PostScriptName"),
      ": ",
      code$3(font.postscriptName),
      br$2(),
      code$3(
        font.fixedFamily === font.family ? "Family" : "Family (Identified by Typst)"
      ),
      ": ",
      code$3(
        font.fixedFamily === font.family ? font.family : `${font.family} (${font.fixedFamily})`
      )
    );
  };
  const ArgSlots = () => {
    const res = [];
    let val = serverInfos.val["primary"];
    if (val.root) {
      res.push(
        div$3(
          a$3({ href: "javascript:void(0)" }, code$3("root")),
          ": ",
          code$3(val.root)
        )
      );
    }
    for (let i2 = 0; i2 < val.fontPaths.length; i2++) {
      res.push(
        div$3(
          a$3({ href: "javascript:void(0)" }, code$3(`font-path(${i2})`)),
          ": ",
          code$3(val.fontPaths[i2])
        )
      );
    }
    if (val.inputs) {
      const codeList = [];
      for (const key of Object.keys(val.inputs)) {
        codeList.push(
          span$3({ style: "color: #DEC76E" }, key),
          span$3({ style: "color: #7DCFFF" }, "="),
          val.inputs[key]
        );
      }
      res.push(
        div$3(
          a$3({ href: "javascript:void(0)" }, code$3("sys.inputs")),
          ": ",
          code$3(...codeList)
        )
      );
      for (const [key, htmlContent] of Object.entries(val.stats)) {
        res.push(
          div$3(
            div$3({ href: "javascript:void(0)" }, code$3(key)),
            div$3({ innerHTML: htmlContent })
          )
        );
      }
    }
    return res;
  };
  return div$3(
    {
      class: "flex-col",
      style: "justify-content: center; align-items: center; gap: 10px;"
    },
    div$3(
      { class: `tinymist-card`, style: "flex: 1; width: 100%; padding: 10px" },
      div$3(
        van.derive(() => `This document is compiled with following arguments.`)
      ),
      div$3({ style: "margin: 1.2em; margin-left: 0.5em" }, ...ArgSlots())
    ),
    div$3(
      { class: `tinymist-card`, style: "flex: 1; width: 100%; padding: 10px" },
      div$3(
        { style: "position: relative; width: 100%; height: 0px" },
        button$1(
          {
            class: "tinymist-button",
            style: "position: absolute; top: 0px; right: 0px",
            onclick: () => {
              startModal(
                div$3(
                  {
                    style: "height: calc(100% - 20px); box-sizing: border-box; padding-top: 4px"
                  },
                  fontsExportPanel({
                    fonts: docMetrics.val.fontInfo,
                    sources: docMetrics.val.spanInfo.sources
                  })
                )
              );
            }
          },
          CopyIcon()
        )
      ),
      div$3(
        van.derive(
          () => `This document uses ${docMetrics.val.fontInfo.length} fonts.`
        )
      ),
      (_dom) => div$3(
        ...docMetrics.val.fontInfo.sort((x, y) => {
          if (x.usesScale === void 0 || y.usesScale === void 0) {
            if (x.usesScale === void 0) {
              return 1;
            }
            if (y.usesScale === void 0) {
              return -1;
            }
            return x.name.localeCompare(y.name);
          }
          if (x.usesScale !== y.usesScale) {
            return y.usesScale - x.usesScale;
          }
          return x.name.localeCompare(y.name);
        }).map(FontSlot)
      )
    ),
    div$3(
      {
        class: `tinymist-card hidden`,
        style: "flex: 1; width: 100%; padding: 10px"
      },
      div$3(`The Tinymist service.`),
      div$3(
        { style: "margin: 0.8em; margin-left: 0.5em" },
        div$3(
          `Its version is `,
          a$3({ href: "javascript:void(0)" }, "0.11.6"),
          `.`
        ),
        div$3(`It is compiled with optimization level `, "3", `.`),
        div$3(
          `It is connecting to the client `,
          code$3({ style: "font-style: italic" }, "VSCode 1.87.2"),
          `.`
        )
      )
    ),
    div$3(
      {
        class: `tinymist-card hidden`,
        style: "flex: 1; width: 100%; padding: 10px"
      },
      div$3(`The Typst compiler.`),
      div$3(
        { style: "margin: 0.8em; margin-left: 0.5em" },
        div$3(
          `Its version is `,
          a$3({ href: "javascript:void(0)" }, "0.11.0"),
          `.`
        ),
        div$3(
          `It identifies `,
          a$3({ href: "javascript:void(0)" }, "374"),
          ` font variants.`
        )
      )
    ),
    div$3(
      {
        class: `tinymist-card hidden`,
        style: "flex: 1; width: 100%; padding: 10px"
      },
      div$3(`The Typst formatters.`),
      div$3(
        { style: "margin: 0.8em; margin-left: 0.5em" },
        div$3(`It uses typstyle with following configurations.`),
        code$3(
          { style: "margin-left: 0.5em" },
          a$3({ href: "javascript:void(0)", style: "color: #DEC76E" }, "columns"),
          span$3({ style: "color: #7DCFFF" }, "="),
          "120"
        ),
        div$3(
          `The version of typstyle is `,
          a$3({ href: "javascript:void(0)" }, "0.11.7"),
          `.`
        ),
        div$3(
          `The version of typstfmt is `,
          a$3({ href: "javascript:void(0)" }, "0.2.9"),
          `.`
        )
      )
    )
  );
};
const _fontsCSVGenerator = class _fontsCSVGenerator {
  generate(fonts, config) {
    const fields = _fontsCSVGenerator.fieldExtractors.filter(
      (field) => config.fields.includes(field.fieldName)
    );
    const headers = fields.map((field) => field.fieldName);
    let rows = fonts.map(
      (font) => fields.map((field) => field.extractor(font))
    );
    if (fields.length === 1 && fields[0].fieldName === "path") {
      const dedup = /* @__PURE__ */ new Set();
      rows = rows.reduce(
        (acc, item) => {
          const path = item[0];
          if (!dedup.has(path)) {
            dedup.add(path);
            acc.push(item);
          }
          return acc;
        },
        []
      );
    }
    return stringify(rows, {
      header: config.header,
      columns: headers,
      delimiter: config.delimiter
    });
  }
};
__publicField(_fontsCSVGenerator, "fieldExtractors", [
  {
    fieldName: "name",
    extractor: (info) => info.fullName ?? ""
  },
  {
    fieldName: "postscript",
    extractor: (info) => info.postscriptName
  },
  {
    fieldName: "style",
    extractor: (info) => info.style ?? ""
  },
  {
    fieldName: "weight",
    extractor: (info) => info.weight ?? ""
  },
  {
    fieldName: "stretch",
    extractor: (info) => info.stretch ?? ""
  },
  {
    fieldName: "location",
    extractor: (info) => {
      var _a2;
      switch (((_a2 = info.source) == null ? void 0 : _a2.kind) ?? "") {
        case "fs":
          return "fileSystem";
        case "memory":
          return "memory";
        default:
          return "unknown";
      }
    }
  },
  {
    fieldName: "path",
    extractor: (info) => {
      var _a2;
      return ((_a2 = info.source) == null ? void 0 : _a2.kind) === "fs" ? info.source.path : "";
    }
  }
]);
let fontsCSVGenerator = _fontsCSVGenerator;
const fontsExportDefaultConfigure = {
  format: "csv",
  filters: {
    location: ["fs"]
  },
  csv: {
    header: false,
    delimiter: ",",
    fields: ["name", "path"]
  },
  json: {
    indent: 2
  }
};
let savedConfigureData = `:[[preview:FontsExportConfigure]]:`;
const fontsExportPanel = ({ fonts, sources }) => {
  const savedConfigure = savedConfigureData.startsWith(
    ":"
  ) ? fontsExportDefaultConfigure : JSON.parse(base64Decode(savedConfigureData));
  const exportFormat = van.state(savedConfigure.format);
  const locationFilter = van.state(
    savedConfigure.filters.location
  );
  const csvConfigure = van.state(savedConfigure.csv);
  const jsonConfigure = van.state(
    savedConfigure.json
  );
  van.derive(() => {
    const configure = {
      format: exportFormat.val,
      filters: {
        location: locationFilter.val
      },
      csv: csvConfigure.val,
      json: jsonConfigure.val
    };
    savedConfigureData = base64Encode(JSON.stringify(configure));
    requestSaveFontsExportConfigure(configure);
  });
  const data = fonts.map((font) => {
    let source = typeof font.source === "number" ? sources[font.source] : null;
    return Object.assign({}, font, { source });
  });
  const filteredData = van.derive(() => {
    return data.filter(
      (font) => {
        var _a2;
        return locationFilter.val.includes(((_a2 = font.source) == null ? void 0 : _a2.kind) ?? "");
      }
    );
  });
  const exportText = van.derive(() => {
    switch (exportFormat.val) {
      case "csv": {
        const csvGenerator = new fontsCSVGenerator();
        return csvGenerator.generate(filteredData.val, csvConfigure.val);
      }
      case "json": {
        return JSON.stringify(filteredData.val, null, jsonConfigure.val.indent);
      }
    }
  });
  const titleWidth = 72;
  const rowGap = 8;
  const labelInputGap = 4;
  const itemGap = 10;
  const groupGap = 20;
  const labeledInput = (title, el, { labelStyle } = { labelStyle: "" }) => span$3(
    {
      style: `display: inline-flex; column-gap: ${labelInputGap}px; align-items: center`
    },
    label({ for: el.id, style: labelStyle }, title),
    el
  );
  const makeArrayCheckbox = (id, value, state2) => {
    const checked2 = Array.isArray(state2) ? state2.includes(value) : state2.val.includes(value);
    return input({
      id,
      type: "checkbox",
      style: "margin: 0px",
      value,
      checked: checked2,
      onchange: (e) => {
        if (e.target.checked) {
          Array.isArray(state2) ? state2.push(e.target.value) : state2.val = [...state2.rawVal, e.target.value];
        } else {
          if (Array.isArray(state2)) {
            let index = state2.indexOf(e.target.value);
            if (index !== -1) {
              state2.splice(index, 1);
            }
          } else {
            state2.val = state2.val.filter((v) => v !== e.target.value);
          }
        }
      }
    });
  };
  const filtersUI = () => div$3(
    { class: "flex-col", style: `row-gap: ${rowGap}px` },
    div$3(
      { class: "flex-row", style: "align-items: center" },
      div$3({ style: `width: ${titleWidth}px` }, "Location"),
      div$3(
        {
          class: "flex-row",
          style: `flex: 1; flex-wrap: wrap; column-gap: ${itemGap}px`
        },
        labeledInput(
          "FileSystem",
          makeArrayCheckbox("filter-locations-fs", "fs", locationFilter)
        ),
        labeledInput(
          "Memory",
          makeArrayCheckbox(
            "filter-locations-memory",
            "memory",
            locationFilter
          )
        )
      )
    )
  );
  const chooseExportFormatUI = () => div$3(
    { class: "flex-row", style: "align-items: center" },
    div$3({ style: `width: ${titleWidth}px` }, "Format"),
    div$3(
      {
        class: "flex-row",
        style: `flex: 1; flex-wrap: wrap; column-gap: ${itemGap}px`
      },
      labeledInput(
        "CSV",
        input({
          id: "export-format-csv",
          type: "radio",
          name: "export-format",
          style: "margin: 0px",
          checked: exportFormat.val === "csv",
          onchange: (e) => {
            if (e.target.checked) {
              exportFormat.val = "csv";
            }
          }
        })
      ),
      labeledInput(
        "JSON",
        input({
          id: "export-format-json",
          type: "radio",
          name: "export-format",
          style: "margin: 0px",
          checked: exportFormat.val === "json",
          onchange: (e) => {
            if (e.target.checked) {
              exportFormat.val = "json";
            }
          }
        })
      )
    )
  );
  const csvConfigureUI = () => form(
    {
      class: "flex-col",
      style: `row-gap: ${rowGap}px`,
      onchange: (_e) => {
        csvConfigure.val = Object.assign({}, csvConfigure.val);
      },
      onsubmit: (e) => e.preventDefault()
    },
    div$3(
      { class: "flex-row", style: "align-items: center" },
      div$3({ style: `width: ${titleWidth}px` }, "Settings"),
      div$3(
        {
          class: "flex-row",
          style: `flex: 1; flex-wrap: wrap; column-gap: ${groupGap}px`
        },
        labeledInput(
          "Header",
          input({
            id: "csv-header",
            type: "checkbox",
            style: "margin: 0px",
            checked: csvConfigure.val.header,
            onchange: (e) => csvConfigure.rawVal.header = e.target.checked
          })
        ),
        labeledInput(
          "Delimiter:",
          input({
            id: "csv-delimiter",
            type: "input",
            style: `width: 40px`,
            value: csvConfigure.val.delimiter,
            oninput: (e) => csvConfigure.rawVal.delimiter = e.target.value,
            onkeydown: (e) => e.stopPropagation()
            // prevent modal window closed by space when input
          })
        )
      )
    ),
    div$3(
      { class: "flex-row", style: "align-items: center" },
      div$3({ style: `width: ${titleWidth}px` }, "Fields"),
      div$3(
        {
          class: "flex-row",
          style: `flex: 1; flex-wrap: wrap; column-gap: ${itemGap}px`
        },
        ...fontsCSVGenerator.fieldExtractors.map((fe) => fe.fieldName).map(
          (field) => labeledInput(
            field,
            makeArrayCheckbox(
              `csv-field-${field}`,
              field,
              csvConfigure.rawVal.fields
            )
          )
        )
      )
    )
  );
  const jsonConfigureUI = () => form(
    {
      onchange: (_e) => {
        jsonConfigure.val = Object.assign({}, jsonConfigure.val);
      },
      onsubmit: (e) => e.preventDefault()
    },
    div$3(
      { class: "flex-row", style: "align-items: center" },
      div$3({ style: `width: ${titleWidth}px` }, "Settings"),
      div$3(
        {
          class: "flex-row",
          style: `flex: 1; flex-wrap: wrap; column-gap: ${groupGap}px`
        },
        labeledInput(
          "Indent:",
          input({
            id: "json-indent",
            type: "number",
            style: "width: 40px;",
            min: "0",
            max: "8",
            step: "2",
            value: jsonConfigure.val.indent,
            onchange: (e) => jsonConfigure.rawVal.indent = parseInt(e.target.value, 10)
          }),
          { labelStyle: "margin-right: 0.5em" }
        )
      )
    )
  );
  const exportFormatConfigureUI = () => {
    let ui;
    switch (exportFormat.val) {
      case "csv": {
        ui = csvConfigureUI();
        break;
      }
      case "json": {
        ui = jsonConfigureUI();
        break;
      }
    }
    return ui;
  };
  return div$3(
    {
      class: "flex-col",
      style: `row-gap: ${rowGap}px; width: 100%; height: 100%`
    },
    filtersUI,
    chooseExportFormatUI,
    exportFormatConfigureUI,
    textarea(
      {
        class: "tinymist-code",
        style: "resize: none; width: 100%; flex: 1; white-space: pre; overflow-wrap: normal; overflow-x: scroll",
        readOnly: true,
        onkeydown: (e) => e.stopPropagation()
      },
      exportText
    ),
    div$3(
      { style: `display: flex; align-items: center; column-gap:${itemGap}px` },
      button$1(
        {
          class: "tinymist-button",
          style: "flex: 1",
          onclick: () => {
            const filterName = `${exportFormat.val.toLocaleUpperCase()} file`;
            saveDataToFile({
              data: exportText.val,
              option: {
                filters: {
                  [filterName]: [exportFormat.val]
                }
              }
            });
          }
        },
        "Export"
      ),
      button$1(
        {
          class: "tinymist-button",
          style: "flex: 1",
          onclick: () => navigator.clipboard.writeText(exportText.val)
        },
        "Copy"
      )
    )
  );
};
const DOC_MOCK$1 = {
  spanInfo: {
    sources: [
      {
        kind: "fs",
        path: "C:\\Users\\OvO\\work\\assets\\fonts\\SongTi-Regular.ttf"
      },
      {
        kind: "fs",
        path: "C:\\Users\\OvO\\work\\assets\\fonts\\TimesNewRoman-Regular.ttf"
      },
      {
        kind: "fs",
        path: "C:\\Users\\OvO\\work\\assets\\fonts\\MicrosoftYaHei-Regular.ttf"
      }
    ]
  },
  fontInfo: [
    {
      name: "Song Ti",
      postscriptName: "SongTi",
      source: 0,
      usesScale: 3
    },
    {
      name: "Times New Roman",
      postscriptName: "TimesNewRoman",
      source: 1,
      usesScale: 4
    },
    {
      name: "Microsoft YaHei",
      postscriptName: "MicrosoftYaHei",
      source: 2,
      usesScale: 2
    }
  ]
};
const SERVER_INFO_MOCK = {
  primary: {
    root: "C:\\Users\\OvO\\work\\rust\\tinymist",
    fontPaths: [
      "C:\\Users\\OvO\\work\\rust\\tinymist\\assets\\fonts",
      "C:\\Users\\OvO\\work\\assets\\fonts"
    ],
    inputs: {
      theme: "dark",
      context: '{"preview":true}'
    },
    stats: {}
  }
};
const { div: div$2, a: a$2, br: br$1, span: span$2, code: code$2 } = van.tags;
const Diagnostics = () => {
  return div$2(
    {
      class: "flex-col",
      style: "justify-content: center; align-items: center; gap: 10px;"
    },
    div$2(
      { class: `tinymist-card`, style: "flex: 1; width: 100%; padding: 10px" },
      code$2(
        { width: "100%" },
        `cannot add integer and alignment`,
        br$1(),
        a$2({ href: "javascript:void(0)" }, "test.typ(3, 19)"),
        `: error occurred in this call of function \`f\``,
        br$1(),
        a$2({ href: "javascript:void(0)" }, `test.typ(6, 2)`),
        `: error occurred in this call of function \`g\``
      )
    ),
    div$2(
      { class: `tinymist-card`, style: "flex: 1; width: 100%; padding: 10px" },
      "Expression explained.",
      div$2(
        {
          style: "margin: 0.8em 0"
        },
        "The expression is: ",
        code$2(a$2({ href: "javascript:void(0)" }, `x`)),
        code$2(` + `),
        code$2(a$2({ href: "javascript:void(0)" }, `y`)),
        ", at location: test.typ(2, 16):",
        br$1(),
        code$2(
          {
            style: "margin: 0.5em"
          },
          `#let f(x, y)  = `,
          span$2({ style: "text-decoration: underline" }, `x + y`),
          `;`
        ),
        br$1(),
        "where ",
        code$2(a$2({ href: "javascript:void(0)" }, `x`)),
        " is the ",
        "1st",
        " function parameter of ",
        code$2(a$2({ href: "javascript:void(0)" }, `f`)),
        ".",
        br$1(),
        "where ",
        code$2(a$2({ href: "javascript:void(0)" }, `y`)),
        " is the ",
        "2nd",
        " function parameter of ",
        code$2(a$2({ href: "javascript:void(0)" }, `f`)),
        "."
      ),
      div$2(
        {
          style: "margin: 0.8em 0"
        },
        code$2(a$2({ href: "javascript:void(0)" }, `f`)),
        " is called with arguments ",
        code$2("f("),
        code$2(a$2({ href: "javascript:void(0)" }, `x`)),
        code$2(` = 1, `),
        code$2(a$2({ href: "javascript:void(0)" }, `y`)),
        code$2(" = left)"),
        ", at location: test.typ(3, 19):",
        br$1(),
        code$2(
          {
            style: "margin: 0.5em"
          },
          `#let g(x, y, z) = `,
          span$2({ style: "text-decoration: underline" }, `f(x, y)`),
          ` + z;`
        ),
        br$1(),
        "where ",
        code$2(a$2({ href: "javascript:void(0)" }, `x`)),
        " is the ",
        "1st",
        " function parameter of ",
        code$2(a$2({ href: "javascript:void(0)" }, `g`)),
        ".",
        br$1(),
        "where ",
        code$2(a$2({ href: "javascript:void(0)" }, `y`)),
        " is the ",
        "2nd",
        " function parameter of ",
        code$2(a$2({ href: "javascript:void(0)" }, `g`)),
        "."
      ),
      div$2(
        {
          style: "margin: 0.8em 0"
        },
        code$2(a$2({ href: "javascript:void(0)" }, `g`)),
        " is called with arguments ",
        code$2("g("),
        code$2(`x`),
        code$2(` = 1, `),
        code$2(`y`),
        code$2(" = left, z = red)"),
        ", at location: test.typ(6, 2):",
        br$1(),
        code$2(
          {
            style: "margin: 0.5em"
          },
          `#`,
          span$2({ style: "text-decoration: underline" }, `g(1, left, red)`),
          `;`
        )
      )
    )
  );
};
const docs = "";
const { div: div$1, h1, h2, h3, code: code$1, a: a$1, p, i, span: span$1, strong } = van.tags;
const docsMock = "";
const Docs = () => {
  const parsedDocs = van.state({
    contents: [],
    children: [],
    kind: 0,
    id: "",
    data: null
  });
  const favoritePlaceholders = `:[[preview:DocContent]]:`;
  van.derive(async () => {
    const inp = favoritePlaceholders.startsWith(":") ? docsMock : base64Decode(favoritePlaceholders);
    if (!inp) {
      return;
    }
    parsedDocs.val = await recoverDocsStructure(inp);
  });
  return div$1(
    {
      class: "tinymist-docs flex-col",
      style: "justify-content: center; align-items: center; gap: 10px;"
    },
    div$1(
      {
        style: "flex: 1; width: 100%; padding: 10px"
      },
      (_dom) => {
        const v = parsedDocs.val;
        return div$1(MakeDoc(v));
      }
    )
  );
};
async function recoverDocsStructure(content) {
  console.log("recoverDocsStructure", { content });
  let reg = /<!--(.*?)-->/g;
  let tokenPromises = [];
  let match;
  let lastIndex = 0;
  while (match = reg.exec(content)) {
    tokenPromises.push(
      Promise.resolve([0, content.slice(lastIndex, match.index)])
    );
    tokenPromises.push(identifyCommentToken(match[1]));
    lastIndex = reg.lastIndex;
  }
  tokenPromises.push(Promise.resolve(content.slice(lastIndex)));
  const tokens = await Promise.all(tokenPromises);
  let packageStack = [];
  let structStack = [];
  let current = {
    contents: [],
    children: [],
    kind: 0,
    id: "",
    data: {}
  };
  let currentPkg = current;
  for (const token of tokens) {
    switch (token[0]) {
      case 1:
        structStack.push(current);
        packageStack.push(currentPkg);
        current = {
          contents: [],
          children: [],
          kind: 1,
          id: "",
          data: token[1]
        };
        currentPkg = current;
        break;
      case 2:
        const pkg = current;
        pkg.data = pkg.data || {};
        pkg.data["pkgEndData"] = token[1];
        current = structStack.pop();
        currentPkg = packageStack.pop();
        current.children.push(pkg);
        break;
      case 5:
        currentPkg.data.error = token[1];
        break;
      case 6:
        break;
      case 3: {
        structStack.push(current);
        let sym = void 0;
        for (let i2 = structStack.length - 1; i2 >= 0; i2--) {
          if (structStack[i2].kind === 3) {
            sym = structStack[i2];
            break;
          }
        }
        current = {
          contents: [],
          children: [],
          kind: 4,
          id: token[1],
          data: {
            name: token[1]
          }
        };
        if (sym) {
          current.id = `${sym.id}-param-${token[1]}`;
          const renderedParams = sym.data.renderedParams = sym.data.renderedParams || {};
          renderedParams[current.id] = current;
        }
        break;
      }
      case 4: {
        current = structStack.pop();
        break;
      }
      case 7:
        structStack.push(current);
        current = {
          contents: [],
          children: [],
          kind: 2,
          id: token[1],
          data: token[2]
        };
        break;
      case 8:
        const module = current;
        current = structStack.pop();
        current.children.push(module);
        break;
      case 9:
        structStack.push(current);
        current = {
          contents: [],
          children: [],
          kind: 3,
          id: token[1],
          data: token[2]
        };
        break;
      case 10:
        const symbol = current;
        current = structStack.pop();
        current.children.push(symbol);
        break;
      case 11:
      case 13:
        structStack.push(current);
        current = {
          contents: [],
          children: [],
          kind: 5,
          id: "",
          data: {}
        };
        break;
      case 12:
      case 14:
        current = structStack.pop();
        break;
      case 15:
        break;
      case 0:
        current.contents.push(token[1]);
        break;
    }
  }
  return current;
}
async function identifyCommentToken(comment) {
  const cs = comment.trim().split(" ");
  switch (cs[0]) {
    case "begin:package":
      return [1, JSON.parse(await base64ToUtf8(cs[1]))];
    case "end:package":
      return [2, JSON.parse(await base64ToUtf8(cs[1]))];
    case "begin:param-doc":
      return [3, cs[1]];
    case "end:param-doc":
      return [4, cs[1]];
    case "begin:errors":
      return [5, JSON.parse(await base64ToUtf8(cs[1]))];
    case "end:errors":
      return [6, cs[1]];
    case "begin:module":
      return [
        7,
        cs[1],
        JSON.parse(await base64ToUtf8(cs[2]))
      ];
    case "end:module":
      return [8, cs[1]];
    case "begin:symbol":
      return [
        9,
        cs[1],
        JSON.parse(await base64ToUtf8(cs[2]))
      ];
    case "end:symbol":
      return [10, cs[1]];
    case "begin:sig":
      return [11, cs[1]];
    case "end:sig":
      return [12, cs[1]];
    case "begin:param":
      return [13, cs[1]];
    case "end:param":
      return [14, cs[1]];
    case "typlite:begin:list-item":
    case "typlite:end:list-item":
      return [0, ""];
    default:
      return [15, comment];
  }
}
async function base64ToUtf8(base64) {
  const base64Url = `data:text/plain;base64,${base64}`;
  const res = await fetch(base64Url);
  return await res.text();
}
function MakeDoc(root) {
  let knownFiles = [];
  let knownPackages = [];
  let selfPackageId = -1;
  getKnownPackages(root);
  processInternalModules(root);
  function getKnownPackages(v) {
    for (const child of v.children) {
      if (child.kind === 1) {
        knownFiles = [...child.data.pkgEndData["files"]];
        knownFiles.forEach((e) => {
          e.path = e.path.replace(/\\/g, "/");
        });
        knownPackages = [...child.data.pkgEndData["packages"]];
        selfPackageId = knownPackages.findIndex(
          (e) => e.namespace === child.data.namespace && e.name === child.data.name && e.version === child.data.version
        );
        return;
      }
      getKnownPackages(child);
    }
  }
  function processInternalModules(v) {
    if (v.kind === 2) {
      v.data.aka = v.data.aka || [];
      v.data.realAka = v.data.aka.filter((e) => !e.includes(".-."));
      knownFiles[v.data.loc].isInternal = v.data.realAka.length === 0;
    }
    for (const child of v.children) {
      processInternalModules(child);
    }
  }
  function genFileId(file) {
    if (!file) {
      return "not-found";
    }
    const pkg = knownPackages[file.package];
    const pathId = file.path.replaceAll("\\", ".").replaceAll("/", ".");
    if (pkg) {
      return `module-${pkg.namespace}-${pkg.name}-${pkg.version}-${pathId}`;
    }
    return `module-${pathId}`;
  }
  function getExternalPackage(loc) {
    var _a2, _b;
    if (loc < 0 || loc >= knownFiles.length) {
      return void 0;
    }
    if (((_a2 = knownFiles[loc]) == null ? void 0 : _a2.package) === selfPackageId) {
      return void 0;
    }
    return knownPackages[(_b = knownFiles[loc]) == null ? void 0 : _b.package];
  }
  function Item(v) {
    switch (v.kind) {
      case 1:
        return PackageItem(v);
      case 2:
        if (!v.data.prefix) {
          return ModuleBody(v);
        }
        return ModuleItem(v);
      case 3:
        const kind = v.data.kind;
        switch (kind) {
          case "function":
            return FuncItem(v);
          case "constant":
            return ConstItem(v);
          case "module":
            return ModuleRefItem(v);
          default:
            return div$1();
        }
      case 0:
        return div$1(...v.children.map(Item));
      default:
        return div$1();
    }
  }
  function ItemDoc(v) {
    return div$1({
      style: "margin-left: 0.62em",
      innerHTML: v.contents.join("")
    });
  }
  function ShortItemDoc(v) {
    return [ItemDoc(v)];
  }
  function ModuleBody(v) {
    const modules = [];
    const functions = [];
    const constants = [];
    const unknowns = [];
    for (const child of v.children) {
      switch (child.kind) {
        case 2:
          modules.push(child);
          break;
        case 3:
          switch (child.data.kind) {
            case "function":
              functions.push(child);
              break;
            case "constant":
              constants.push(child);
              break;
            case "module":
              modules.push(child);
              break;
            default:
              unknowns.push(child);
              break;
          }
          break;
      }
    }
    modules.sort((x, y) => {
      var _a2, _b, _c, _d;
      const xIsExternal = knownFiles[(_a2 = x.data) == null ? void 0 : _a2.loc[0]].package;
      const yIsExternal = knownFiles[(_b = y.data) == null ? void 0 : _b.loc[0]].package;
      if (xIsExternal != yIsExternal) {
        return xIsExternal ? 1 : -1;
      }
      const xIsInternal = knownFiles[(_c = x.data) == null ? void 0 : _c.loc[0]].isInternal;
      const yIsInternal = knownFiles[(_d = y.data) == null ? void 0 : _d.loc[0]].isInternal;
      if (xIsInternal != yIsInternal) {
        return xIsInternal ? 1 : -1;
      }
      return x.id.localeCompare(y.id);
    });
    const chs = [];
    if (modules.length > 0) {
      chs.push(h2("Modules"), div$1(...modules.map(ModuleRefItem)));
    }
    if (constants.length > 0) {
      chs.push(h2("Constants"), div$1(...constants.map(Item)));
    }
    if (functions.length > 0) {
      chs.push(h2("Functions"), div$1(...functions.map(Item)));
    }
    if (unknowns.length > 0) {
      chs.push(h2("Unknowns"), div$1(...unknowns.map(Item)));
    }
    return div$1(...chs);
  }
  function ModuleItem(v) {
    var _a2, _b;
    const fileLoc = v.data.loc;
    const fid = genFileId(knownFiles[fileLoc]);
    const isInternal = (_a2 = knownFiles[fileLoc]) == null ? void 0 : _a2.isInternal;
    const title = [];
    if (isInternal) {
      title.push(
        span$1(
          {
            style: "text-decoration: underline",
            title: `It is inaccessible by paths`
          },
          "Module"
        ),
        code$1(" ", ((_b = knownFiles[fileLoc]) == null ? void 0 : _b.path) || v.id)
      );
    } else {
      title.push(span$1(`Module: ${v.id}`));
    }
    return div$1(
      { class: "tinymist-module" },
      h1({ id: v.id }, ...fid ? [span$1({ id: fid }, ...title)] : title),
      ModuleBody(v)
    );
  }
  function PackageItem(v) {
    return div$1(
      h1(`@${v.data.namespace}/${v.data.name}:${v.data.version}`),
      p(
        span$1(
          "This documentation is generated locally. Please submit issues to "
        ),
        a$1(
          { href: "https://github.com/Myriad-Dreamin/tinymist/issues" },
          "tinymist"
        ),
        span$1(" if you see "),
        strong(i("incorrect")),
        span$1(" information in it.")
      ),
      ...v.children.map(Item)
    );
  }
  function ModuleRefItem(v) {
    const fileLoc = v.data.loc;
    const extPkg = getExternalPackage(fileLoc == null ? void 0 : fileLoc[0]);
    const internal = knownFiles[fileLoc == null ? void 0 : fileLoc[0]].isInternal;
    let body;
    if (extPkg) {
      body = code$1(
        extPkg.namespace === "preview" ? a$1(
          {
            href: `https://typst.app/universe/package/${extPkg.name}/${extPkg.version}`,
            style: "text-decoration: underline",
            title: `In external package @${extPkg.namespace}/${extPkg.name}:${extPkg.version}`
          },
          "external"
        ) : span$1(
          {
            style: "text-decoration: underline",
            title: `In local package @${extPkg.namespace}/${extPkg.name}:${extPkg.version}`
          },
          "external"
        ),
        code$1(" ", v.data.name)
      );
    } else {
      const file = knownFiles[fileLoc == null ? void 0 : fileLoc[0]];
      const fid = genFileId(file);
      const bodyPre = internal ? code$1(
        span$1(
          {
            style: "text-decoration: underline",
            title: `This module is inaccessible by paths`
          },
          "internal"
        ),
        code$1(" ")
      ) : code$1();
      body = code$1(
        bodyPre,
        a$1(
          {
            href: `#${fid}`
          },
          v.data.name
        )
      );
    }
    return div$1(
      {
        id: v.id,
        class: "tinymist-module-ref"
      },
      div$1(
        {
          class: `detail-header doc-symbol-${v.data.kind}`
          //   <a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/float.ex#L283" class="icon-action" rel="help" title="View Source">
          //   <i class="ri-code-s-slash-line" aria-hidden="true"></i>
          //   <span class="sr-only">View Source</span>
          // </a>
        },
        h3({ class: "doc-symbol-name" }, body)
      )
    );
  }
  function FuncItem(v) {
    var _a2;
    const sig = (_a2 = v.data) == null ? void 0 : _a2.parsed_docs;
    const is_external = v.data.is_external ? [kwHl("external"), code$1(" ")] : [];
    const name = a$1(
      {
        id: v.id
      },
      code$1(v.data.name)
    );
    let funcTitle = [...is_external, name];
    if (sig) {
      funcTitle.push(code$1("("));
      for (let i2 = 0; i2 < sig.pos.length; i2++) {
        if (i2 > 0) {
          funcTitle.push(code$1(", "));
        }
        funcTitle.push(code$1(sig.pos[i2].name));
      }
      if (sig.rest || Object.keys(sig.named).length > 0) {
        if (sig.pos.length > 0) {
          funcTitle.push(code$1(", "));
        }
        funcTitle.push(code$1(".."));
      }
      funcTitle.push(code$1(")"));
      if (sig.ret_ty) {
        funcTitle.push(code$1(" -> "));
        typeHighlighted(sig.ret_ty[0], funcTitle);
      }
    }
    return div$1(
      {
        class: "tinymist-symbol"
      },
      div$1(
        {
          class: `detail-header doc-symbol-${v.data.kind}`
        },
        h3({ class: "doc-symbol-name" }, code$1(...funcTitle))
      ),
      ...SigPreview(v),
      ...v.data.is_external ? ShortItemDoc(v) : [ItemDoc(v), ...SigDocs(v)]
    );
  }
  function SigDocs(v) {
    const sig = v.data.parsed_docs;
    const res = [];
    if (!sig) {
      return res;
    }
    const docsMapping = /* @__PURE__ */ new Map();
    for (const param of sig.pos) {
      docsMapping.set(param.name, param);
    }
    for (const param of Object.values(sig.named)) {
      docsMapping.set(param.name, param);
    }
    if (sig.rest) {
      docsMapping.set(sig.rest.name, sig.rest);
    }
    if (v.data.renderedParams) {
      for (const p2 of Object.values(v.data.renderedParams)) {
        const param = p2;
        const docs2 = param.contents.join("");
        const prev = docsMapping.get(param.data.name) || {};
        prev.docs = docs2;
        docsMapping.set(param.data.name, prev);
      }
    }
    const paramsAll = [
      ...sig.pos.map((param) => ({ kind: "pos", param })),
      ...sig.rest ? [{ kind: "rest", param: sig.rest }] : [],
      ...Object.entries(sig.named).map(([name, param]) => ({
        kind: "named",
        name,
        param
      }))
    ];
    if (sig.ret_ty) {
      let paramTitle = [codeHl("op", "-> ")];
      sigTypeHighlighted(sig.ret_ty, paramTitle);
      res.push(h3("Resultant"));
      res.push(
        div$1(
          {
            style: "margin-left: 0.62em"
          },
          div$1(
            {
              style: "margin-left: 0.62em"
            },
            div$1(
              {
                class: "doc-param-title"
              },
              strong(paramTitle)
            )
          )
        )
      );
    }
    if (paramsAll.length) {
      res.push(h3("Parameters"));
    }
    for (const { kind, param } of paramsAll) {
      let docs2 = [];
      const docsMeta = docsMapping.get(param.name);
      if (docsMeta == null ? void 0 : docsMeta.docs) {
        docs2 = [docsMeta.docs];
      }
      let paramTitle = [
        code$1(
          {
            id: `param-${v.id}-${param.name}`
          },
          param.name
        )
      ];
      if (param.cano_type) {
        paramTitle.push(code$1(": "));
        sigTypeHighlighted(param.cano_type, paramTitle);
      }
      if (param.default) {
        paramTitle.push(codeHl("op", " = "));
        paramTitle.push(code$1(param.default));
      }
      if (kind == "pos") {
        paramTitle.push(code$1(" (positional)"));
      } else if (kind == "rest") {
        paramTitle.push(code$1(" (rest)"));
      }
      const docsAll = docs2.join("");
      res.push(
        div$1(
          {
            style: "margin-left: 0.62em"
          },
          div$1(
            {
              class: "doc-param-title"
            },
            strong(code$1(paramTitle))
          ),
          div$1({
            style: "margin-left: 0.62em",
            innerHTML: docsAll ? docsAll : "<p>-</p>"
          })
        )
      );
    }
    return res;
  }
  function SigPreview(v) {
    const sig = v.data.parsed_docs;
    if (!sig) {
      return [];
    }
    const res = [];
    const paramsAll = [
      ...sig.pos.map((param) => ({ kind: "pos", param })),
      ...Object.entries(sig.named).map(([name, param]) => ({
        kind: "named",
        name,
        param
      })),
      ...sig.rest ? [{ kind: "rest", param: sig.rest }] : []
    ];
    const is_external = v.data.is_external ? [
      a$1(
        {
          href: v.data.external_link,
          title: "this symbol is re-exported from other modules"
        },
        kwHl("external")
      ),
      code$1(" ")
    ] : [];
    const sigTitle = [
      ...is_external,
      kwHl("let"),
      code$1(" "),
      code$1(fnHl(v.data.name)),
      code$1("(")
    ];
    for (let i2 = 0; i2 < paramsAll.length; i2++) {
      if (i2 > 0) {
        sigTitle.push(code$1(", "));
      }
      let paramTitle = [];
      if (paramsAll[i2].kind == "rest") {
        paramTitle.push(code$1(".."));
      }
      paramTitle.push(code$1(paramsAll[i2].param.name));
      if (paramsAll[i2].kind == "named") {
        paramTitle.push(code$1("?"));
      }
      sigTitle.push(
        a$1(
          {
            href: `#param-${v.id}-${paramsAll[i2].param.name}`
          },
          ...paramTitle
        )
      );
    }
    sigTitle.push(code$1(")"));
    if (sig.ret_ty) {
      sigTitle.push(code$1(" -> "));
      typeHighlighted(sig.ret_ty[0], sigTitle);
    }
    sigTitle.push(code$1(";"));
    res.push(
      div$1(
        { style: "margin-left: 0.62em" },
        div$1({
          style: "font-size: 1.5em; margin: 0.5em 0"
        }),
        div$1(
          {
            style: "margin: 0 1em"
          },
          code$1(...sigTitle)
        )
      )
    );
    return res;
  }
  function ConstItem(v) {
    return div$1(
      {
        class: "tinymist-symbol"
      },
      div$1(
        {
          class: `detail-header doc-symbol-${v.data.kind}`
        },
        h3(
          { class: "doc-symbol-name" },
          code$1(`${v.data.name}`)
          // code(
          //   {
          //     style: "float: right; line-height: 1em",
          //   },
          //   `${v.data.kind}`
          // )
        )
      ),
      ItemDoc(v)
    );
  }
  return Item(root);
}
function sigTypeHighlighted(inferred, target) {
  if (inferred) {
    const rendered = [];
    typeHighlighted(inferred[0], rendered, "|");
    const infer = span$1(
      { class: "code-kw type-inferred", title: "inferred by type checker" },
      "infer"
    );
    target.push(
      code$1(
        { class: "type-inferred" },
        infer,
        code$1(" "),
        span$1({ class: "type-inferred-as", title: inferred[1] }, ...rendered)
      )
    );
  }
}
function typeHighlighted(types, target, by = /[|,]/g) {
  const type = types.split(by);
  for (let i2 = 0; i2 < type.length; i2++) {
    if (i2 > 0) {
      target.push(code$1(" | "));
    }
    const ty = type[i2].trim();
    switch (ty) {
      case "int":
      case "integer":
        target.push(code$1({ class: "type-int" }, ty));
        break;
      case "float":
        target.push(code$1({ class: "type-float" }, ty));
        break;
      case "string":
      case "array":
      case "dictionary":
      case "content":
      case "str":
      case "bool":
      case "boolean":
        target.push(code$1({ class: "type-builtin" }, ty));
        break;
      case "auto":
        target.push(code$1({ class: "type-auto" }, ty));
        break;
      case "none":
        target.push(code$1({ class: "type-none" }, ty));
        break;
      default:
        target.push(code$1(type[i2]));
        break;
    }
  }
}
function kwHl(kw) {
  return code$1({ class: "code-kw" }, kw);
}
function fnHl(fn) {
  return code$1({ class: "code-func" }, fn);
}
function codeHl(cls, c) {
  return code$1({ class: `code-${cls}` }, c);
}
const { div, a, span, code, br, button } = van.tags;
const FontView = () => {
  const showNumber = van.state(false);
  const showNumberOpt = van.derive(() => ({ showNumber: showNumber.val }));
  const FontResourcesData = `:[[preview:FontInformation]]:`;
  const fontResources = van.state(
    FontResourcesData.startsWith(":") ? DOC_MOCK : JSON.parse(base64Decode(FontResourcesData))
  );
  console.log("fontResources", fontResources);
  const StyleAtCursorData = `:[[preview:StyleAtCursor]]:`;
  const lastStylesAtCursor = van.state(
    StyleAtCursorData.startsWith(":") ? void 0 : JSON.parse(base64Decode(StyleAtCursorData))
  );
  console.log("styleAtCursorBase", lastStylesAtCursor);
  van.derive(() => {
    var _a2, _b;
    if (styleAtCursor.val && styleAtCursor.val.version) {
      console.log("styleAtCursor", styleAtCursor, lastStylesAtCursor);
      if (!(typeof ((_a2 = lastStylesAtCursor.val) == null ? void 0 : _a2.version) == "number") || lastStylesAtCursor.val.version < ((_b = styleAtCursor.val) == null ? void 0 : _b.version)) {
        lastStylesAtCursor.val = styleAtCursor.val;
      }
      return;
    }
  });
  const style2 = van.derive(() => {
    var _a2;
    if (!(typeof ((_a2 = lastStylesAtCursor.val) == null ? void 0 : _a2.version) == "number")) {
      return {};
    }
    console.log("lastStylesAtCursor", lastStylesAtCursor);
    return lastStylesAtCursor.val.selections[0] || {};
  });
  const fontAtCursor = van.derive(() => {
    var _a2, _b;
    const resolved = ((_b = (_a2 = style2.val) == null ? void 0 : _a2.styleAt) == null ? void 0 : _b[0].toString()) || "";
    console.log("style", style2, resolved);
    return resolved;
  });
  const fontPosition = van.derive(() => {
    var _a2, _b, _c;
    if (((_b = (_a2 = style2.val) == null ? void 0 : _a2.textDocument) == null ? void 0 : _b.uri) && ((_c = style2.val) == null ? void 0 : _c.position)) {
      return `${style2.val.textDocument.uri}:${style2.val.position.line}:${style2.val.position.character}`;
    }
    return "";
  });
  const FontAction = (icon, title, onclick, opts) => {
    const classProp = (opts == null ? void 0 : opts.active) ? van.derive(
      () => {
        var _a2;
        return `tinymist-button tinymist-font-action${((_a2 = opts == null ? void 0 : opts.active) == null ? void 0 : _a2.val) ? " activated" : ""}`;
      }
    ) : "tinymist-button tinymist-font-action";
    return button(
      {
        ...opts,
        class: classProp,
        style: "height: 1.2rem",
        title,
        onclick
      },
      icon
    );
  };
  const FontSlot = (font) => {
    let fileName;
    if (typeof font.source === "number") {
      let w = fontResources.val.sources[font.source];
      if (w.kind === "fs") {
        fileName = w.path.split(/[\\\/]/g).pop();
      } else {
        fileName = `Embedded: ${w.name}`;
      }
    }
    const machineTitle = `Weight ${font.weight || 400}, Stretch ${font.stretch || 1e3}, at `;
    const baseName = code(
      font.style === "normal" || !font.style ? "" : `${humanStyle(font.style)}, `,
      (_dom) => {
        return span(
          humanWeight(font.weight, showNumberOpt.val),
          showNumber.val ? ", " : " ",
          humanStretch(font.stretch, showNumberOpt.val)
        );
      },
      ` (${fileName})`
    );
    let variantName;
    if (typeof font.source === "number") {
      let w = fontResources.val.sources[font.source];
      let title;
      if (w.kind === "fs") {
        title = machineTitle + w.path;
        variantName = a(
          {
            style: "font-size: 1.2em; text-decoration: underline; cursor: pointer;",
            title,
            onclick() {
              if (w.kind === "fs") {
                requestRevealPath(w.path);
              }
            }
          },
          baseName
        );
      } else {
        title = machineTitle + `Embedded: ${w.name}`;
        variantName = span(
          {
            style: "font-size: 1.2em",
            title
          },
          baseName
        );
      }
    } else {
      variantName = a({ style: "font-size: 1.2em" }, baseName);
    }
    return div({ style: "margin-left: 0.5em" }, variantName);
  };
  function activeMe(d) {
    d.classList.add("active");
    setTimeout(() => d.classList.remove("active"), 500);
  }
  const FontFamilySlot = (family) => {
    const name = `"${family.name || ""}"`;
    return div(
      { class: `tinymist-card`, style: "flex: 1; width: 100%; padding: 10px" },
      (_dom) => div(
        { style: "margin: 1.2em; margin-left: 0.5em" },
        div(
          FontAction(
            "Copy",
            "Copy to clipboard",
            function() {
              activeMe(this);
              copyToClipboard(`"${family.name || ""}"`);
            }
          ),
          " | ",
          FontAction(
            "Paste string",
            "Paste as String",
            function() {
              activeMe(this);
              const rest = name;
              const markup = `#${rest}`;
              requestTextEdit({
                newText: {
                  kind: "by-mode",
                  markup,
                  rest
                }
              });
            }
          ),
          " ",
          FontAction(
            "#set",
            "Paste as Set Font Rule",
            function() {
              activeMe(this);
              const rest = name;
              const markup = `#set text(font: ${rest})`;
              requestTextEdit({
                newText: {
                  kind: "by-mode",
                  markup,
                  rest
                }
              });
            }
          )
        ),
        span({ style: "font-size: 1.2em" }, family.name),
        ".",
        br(),
        code("Variant"),
        ": ",
        family.infos.map(FontSlot)
      )
    );
  };
  const SelectingSlot = () => {
    return div(
      { style: "margin: 1.2em; margin-left: 0.5em" },
      "The font of selecting content is ",
      code(fontAtCursor),
      br(),
      "Checked at ",
      code(fontPosition)
    );
  };
  return div(
    {
      style: "width: 100%;"
    },
    (_dom) => div(
      {
        class: "flex-col",
        style: "justify-content: center; align-items: center; gap: 10px; width: 100%;"
      },
      div(
        {
          style: "flex: 1; width: 100%; padding: 10px"
        },
        FontAction(
          "Show Number",
          "Toggle to show weight or stretch number",
          () => {
            showNumber.val = !showNumber.val;
          },
          { active: showNumber }
        )
      ),
      div(
        {
          class: `tinymist-card`,
          style: "flex: 1; width: 100%; padding: 10px; display: none"
        },
        (_dom2) => SelectingSlot()
      ),
      ...fontResources.val.families.map(FontFamilySlot)
    )
  );
};
const DOC_MOCK = {
  sources: [
    {
      kind: "fs",
      path: "C:\\Users\\OvO\\work\\assets\\fonts\\SongTi-Regular.ttf"
    },
    {
      kind: "fs",
      path: "C:\\Users\\OvO\\work\\assets\\fonts\\TimesNewRoman-Regular.ttf"
    },
    {
      kind: "fs",
      path: "C:\\Users\\OvO\\work\\assets\\fonts\\MicrosoftYaHei-Regular.ttf"
    }
  ],
  families: [
    {
      name: "Song Ti",
      infos: [
        {
          name: "Song Ti",
          source: 0
        }
      ]
    },
    {
      name: "Times New Roman",
      infos: [
        {
          name: "Times New Roman",
          source: 1
        }
      ]
    },
    {
      name: "Microsoft YaHei",
      infos: [
        {
          name: "Microsoft YaHei",
          source: 2
        }
      ]
    }
  ]
};
mainHarness({
  "template-gallery": TemplateGallery,
  tracing: Tracing,
  summary: Summary,
  diagnostics: Diagnostics,
  "font-view": FontView,
  docs: Docs
});

</script>
    <style>
@import url("https://fonts.googleapis.com/css2?family=Merriweather:ital,wght@0,300;0,700;0,900;1,300;1,700&display=swap");html,
body {
  margin: 0;
}

.flex-row {
    display: flex;
    flex-direction: row;
}

.flex-col {
    display: flex;
    flex-direction: column;
}

.tinymist-card {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 0.75rem;
}

.template-card {
  padding: 18px 24px;
  margin: 1em 0;
}

.tinymist-search {
  width: calc(100% - 1em);
  margin: 0.2em;
}

.tinymist-author-container {
  font-size: 0.8em;
}

.tinymist-template-action-container {
  margin-top: 0.2em;
  margin-bottom: 0.3em;
}

.tinymist-category-container {
  margin-bottom: 0.1em;
}

.tinymist-category {
  background: rgba(255, 255, 255, 0.15);
  border-radius: 0.4rem;
  padding: 0.1rem 0.5rem;
}

.tinymist-category-filter {
  display: flex;
  margin-top: 6px;
  gap: 0.5rem;
}

.tinymist-template-actions .tinymist-button div {
  height: 16px;
}

.tinymist-button {
  background: rgba(129, 60, 133, 0.6);
  border: none;
  border-radius: 0.2rem;
  cursor: pointer;
  transition: background 0.15s;
}

.tinymist-button:hover {
  background: rgba(129, 60, 133, 0.9);
}

.tinymist-button.activated {
  background: rgba(129, 60, 133, 0.9);
}

.tinymist-canvas-panel {
  background: rgba(201, 209, 217, 0.15);
  border-radius: 3px;
  width: 160px;
}

.tinymist-symbol-cell {
  background: rgba(201, 209, 217, 0.15);
  border-radius: 3px;

  cursor: pointer;
  transition: color 0.15s;
}

.tinymist-symbol-cell:hover {
  color: rgba(68, 147, 248, 0.9);
}

.tinymist-symbol-cell.active {
  color: rgba(249, 189, 16, 0.9);
  transition: color 0.05s;
}

.tinymist-highlight {
  background: rgba(255, 255, 0, 0.15);
}

.tinymist-code {
  font-family: Cascadia Code, Consolas, SF Mono, DejaVu Sans Mono, monospace;
}

#tinymist-app, .tinymist-main-window {
  margin: 24px 28px;
}

#tinymist-app code, .tinymist-main-window code, .tinymist-window code {
  background-color: transparent;
  padding: 0;
  border-radius: 0;
}

#tinymist-app.no-wrap {
  margin: 0;
}

body.typst-preview-dark {
  --modal-background: rgba(0, 0, 0, 0.6);
}
body.typst-preview-light {
  --modal-background: rgba(255, 255, 255, 0.8);
}

body.typst-preview-dark .tinymist-card {
  background: rgba(193, 108, 108, 0.05);
}
body.typst-preview-dark .tinymist-category {
  background: rgba(255, 255, 255, 0.05);
}
body.typst-preview-dark .tinymist-button {
  background: rgba(129, 60, 133, 0.6);
}
body.typst-preview-dark .tinymist-button:hover {
  background: rgba(129, 60, 133, 0.9);
}
body.typst-preview-dark .tinymist-button.activated {
  background: rgba(129, 60, 133, 0.9);
}
body.typst-preview-dark .tinymist-button.warning {
  background: rgba(252, 211, 55, 0.6);
}
body.typst-preview-dark .tinymist-button.warning:hover {
  background: rgba(252, 211, 55, 0.9);
}
body.typst-preview-dark .tinymist-button.warning.activated {
  background: rgba(252, 211, 55, 0.9);
}

body.typst-preview-light .tinymist-card {
  background: rgba(0, 0, 0, 0.05);
}
body.typst-preview-light .tinymist-category {
  background: rgba(0, 0, 0, 0.05);
}
body.typst-preview-light .tinymist-button {
  background: rgba(186, 204, 217, 0.6);
}
body.typst-preview-light .tinymist-button:hover {
  background: rgba(186, 204, 217, 0.9);
}
body.typst-preview-light .tinymist-button.activated {
  background: rgba(186, 204, 217, 0.9);
}
body.typst-preview-light .tinymist-button.warning {
  background: rgba(243, 202, 99, 0.6);
}
body.typst-preview-light .tinymist-button.warning:hover {
  background: rgba(243, 202, 99, 0.9);
}
body.typst-preview-light .tinymist-button.warning.activated {
  background: rgba(243, 202, 99, 0.9);
}

.tinymist-icon :is(path, rect) {
  fill: currentColor;
}

.tinymist-icon :is(path, rect).stroke-based {
  fill: none;
  stroke: currentColor;
}

.hidden {
  display: none;
}

/* aria-hidden */
span[aria-hidden="true"] {
  display: none;
}


.tinymist-docs {
  --mainLight: hsl(250, 68%, 74%);
  --textDetailAccent: var(--mainLight);
  font-family:
    Merriweather,
    serif,
    "Inter var experimental",
    "Inter var",
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    "Fira Sans",
    "Droid Sans",
    "Helvetica Neue",
    sans-serif;
}

.tinymist-docs code {
  font-family: Menlo, Monaco, "JetBrains Mono", "Fira Code", Consolas,
    "Courier New", monospace;
}

.tinymist-docs h1 {
  font-size: 3em;
}

.tinymist-docs h2 {
  font-size: 1.7em;
  margin-block-start: 1em;
  margin-block-end: 0.83em;
}

.tinymist-docs h3 {
  font-size: 1.17em;
  margin-block-start: 1.17em;
  margin-block-end: 0.83em;
}

.tinymist-docs .detail-header {
  margin: 1em 0;
  margin-top: 1.5em;
  padding: 0.5em 1em;
  background-color: rgba(255, 255, 255, 0.05);
  border-left: 3px solid var(--textDetailAccent);
  font-size: 1em;
  position: relative;
}

.tinymist-docs .detail-header h3.doc-symbol-name {
  font-size: 1em;
  font-weight: 700;
  margin: 0;
}

.tinymist-docs .detail-header .doc-param-title {
  font-size: 1em;
  font-weight: 600;
  margin-block-start: 1.17em;
  margin-block-end: 0.5em;
}

.tinymist-docs .type-int {
  color: #e7d9ff;
}

.tinymist-docs .type-float {
  color: #e7d9ff;
}

.tinymist-docs .type-builtin {
  color: #d2a8ff;
}

.tinymist-docs .type-none {
  color: #ff6d00;
}

.tinymist-docs .code-kw,
.tinymist-docs .type-auto {
  color: #ff6d00;
}

.tinymist-docs .code-func {
  color: #79c0ff;
}

.tinymist-docs .code-op {
  color: #79c0ff;
}

.tinymist-docs .type-inferred-as,
.tinymist-docs .code-kw.type-inferred {
  transition: background-color 0.1s;
}

.tinymist-docs .type-inferred-as:hover,
.tinymist-docs .code-kw.type-inferred:hover {
  background-color: #344134;
}

</style>
  </head>

  <body
    style="
      padding: 0;
      margin: 0;
      height: fit-content;
      width: 100%;
      background-color: var(--typst-preview-background-color, #888) !important;
    "
  >
    <script>
      {
        /// https://stackoverflow.com/questions/13586999/color-difference-similarity-between-two-values-with-js
        function deltaE(rgbA, rgbB) {
          let labA = rgb2lab(rgbA);
          let labB = rgb2lab(rgbB);
          let deltaL = labA[0] - labB[0];
          let deltaA = labA[1] - labB[1];
          let deltaB = labA[2] - labB[2];
          let c1 = Math.sqrt(labA[1] * labA[1] + labA[2] * labA[2]);
          let c2 = Math.sqrt(labB[1] * labB[1] + labB[2] * labB[2]);
          let deltaC = c1 - c2;
          let deltaH = deltaA * deltaA + deltaB * deltaB - deltaC * deltaC;
          deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
          let sc = 1.0 + 0.045 * c1;
          let sh = 1.0 + 0.015 * c1;
          let deltaLKlsl = deltaL / 1.0;
          let deltaCkcsc = deltaC / sc;
          let deltaHkhsh = deltaH / sh;
          let i =
            deltaLKlsl * deltaLKlsl +
            deltaCkcsc * deltaCkcsc +
            deltaHkhsh * deltaHkhsh;
          return i < 0 ? 0 : Math.sqrt(i);
        }

        function rgb2lab(rgb) {
          let r = rgb[0] / 255,
            g = rgb[1] / 255,
            b = rgb[2] / 255,
            x,
            y,
            z;
          r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
          g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
          b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
          x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
          y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.0;
          z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
          x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
          y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
          z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
          return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
        }

        // https://stackoverflow.com/questions/26414770/getting-the-rgb-values-for-a-css-html-named-color-in-javascript
        function cssColorToRgba(cssColor) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          context.fillStyle = cssColor;
          context.fillRect(0, 0, 1, 1);
          return context.getImageData(0, 0, 1, 1).data;
        }

        const themeKind = document.body?.getAttribute("data-vscode-theme-kind");
        const serverDark =
          themeKind === "vscode-dark" ||
          (typeof acquireVsCodeApi === "undefined" &&
            window.matchMedia?.("(prefers-color-scheme: dark)").matches);

        const defaultDarkBackgroundColor = "rgb(17, 17, 17)";
        const defaultLightBackgroundColor = "rgb(255, 255, 255)";
        const defaultBackgroundColor = serverDark
          ? defaultDarkBackgroundColor
          : defaultLightBackgroundColor;
        const defaultToolbarDarkFgColor = "#fff";
        const defaultToolbarLightFgColor = "#000";
        const defaultToolbarFgColor = serverDark
          ? defaultToolbarDarkFgColor
          : defaultToolbarLightFgColor;
        let previewBackgroundColor =
          getComputedStyle(document.documentElement).getPropertyValue(
            "--vscode-sideBar-background"
          ) || defaultBackgroundColor;
        let previewToolbarFgColor =
          getComputedStyle(document.documentElement).getPropertyValue(
            "--vscode-menu-foreground"
          ) || defaultToolbarFgColor;

        let preferColorScheme = "dark";
        /// Perceptible distance between colors:
        /// 0~1: cannot distinguish by human eyes
        /// 1~2: perceptible through close observation
        /// 2~10: perceptible at a glance
        if (
          deltaE(cssColorToRgba(previewBackgroundColor), [255, 255, 255]) < 5
        ) {
          previewBackgroundColor = defaultLightBackgroundColor;
          previewToolbarFgColor = defaultToolbarLightFgColor;
          preferColorScheme = "light";
        }
        document.documentElement.style.colorScheme = preferColorScheme;

        let previewForegroundColor = previewToolbarFgColor;

        const defaultToolbarBorderColor = "rgba(0, 0, 0, 0)";
        const previewToolbarBorderColor =
          getComputedStyle(document.documentElement).getPropertyValue(
            "--vscode-menu-border"
          ) || defaultToolbarBorderColor;

        const defaultToolbarBgColor = "rgb(50, 54, 57)";
        const previewToolbarBgColor =
          getComputedStyle(document.documentElement).getPropertyValue(
            "--vscode-menu-background"
          ) || defaultToolbarBgColor;

        if (serverDark) {
          document.body.classList.add("typst-preview-dark");
        } else {
          document.body.classList.add("typst-preview-light");
        }
        // append css variable --typst-preview-background-color
        document.documentElement.style.setProperty(
          "--typst-preview-background-color",
          previewBackgroundColor
        );
        document.documentElement.style.setProperty(
          "--typst-preview-foreground-color",
          previewForegroundColor
        );
        document.documentElement.style.setProperty(
          "--typst-preview-toolbar-fg-color",
          previewToolbarFgColor
        );
        document.documentElement.style.setProperty(
          "--typst-preview-toolbar-border-color",
          previewToolbarBorderColor
        );
        document.documentElement.style.setProperty(
          "--typst-preview-toolbar-bg-color",
          previewToolbarBgColor
        );
      }
    </script>
    
    <div id="tinymist-app"></div>
  </body>
</html>
